// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: semiotic_classes.proto

#ifndef PROTOBUF_semiotic_5fclasses_2eproto__INCLUDED
#define PROTOBUF_semiotic_5fclasses_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_semiotic_5fclasses_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsCardinalImpl();
void InitDefaultsCardinal();
void InitDefaultsOrdinalImpl();
void InitDefaultsOrdinal();
void InitDefaultsFractionImpl();
void InitDefaultsFraction();
void InitDefaultsTimeImpl();
void InitDefaultsTime();
void InitDefaultsDecimalImpl();
void InitDefaultsDecimal();
void InitDefaultsMeasureImpl();
void InitDefaultsMeasure();
void InitDefaultsDateImpl();
void InitDefaultsDate();
void InitDefaultsMoneyImpl();
void InitDefaultsMoney();
void InitDefaultsTelephoneImpl();
void InitDefaultsTelephone();
void InitDefaultsElectronicImpl();
void InitDefaultsElectronic();
void InitDefaultsConnectorImpl();
void InitDefaultsConnector();
void InitDefaultsAbbreviationImpl();
void InitDefaultsAbbreviation();
inline void InitDefaults() {
  InitDefaultsCardinal();
  InitDefaultsOrdinal();
  InitDefaultsFraction();
  InitDefaultsTime();
  InitDefaultsDecimal();
  InitDefaultsMeasure();
  InitDefaultsDate();
  InitDefaultsMoney();
  InitDefaultsTelephone();
  InitDefaultsElectronic();
  InitDefaultsConnector();
  InitDefaultsAbbreviation();
}
}  // namespace protobuf_semiotic_5fclasses_2eproto
namespace speech {
namespace sparrowhawk {
class Abbreviation;
class AbbreviationDefaultTypeInternal;
extern AbbreviationDefaultTypeInternal _Abbreviation_default_instance_;
class Cardinal;
class CardinalDefaultTypeInternal;
extern CardinalDefaultTypeInternal _Cardinal_default_instance_;
class Connector;
class ConnectorDefaultTypeInternal;
extern ConnectorDefaultTypeInternal _Connector_default_instance_;
class Date;
class DateDefaultTypeInternal;
extern DateDefaultTypeInternal _Date_default_instance_;
class Decimal;
class DecimalDefaultTypeInternal;
extern DecimalDefaultTypeInternal _Decimal_default_instance_;
class Electronic;
class ElectronicDefaultTypeInternal;
extern ElectronicDefaultTypeInternal _Electronic_default_instance_;
class Fraction;
class FractionDefaultTypeInternal;
extern FractionDefaultTypeInternal _Fraction_default_instance_;
class Measure;
class MeasureDefaultTypeInternal;
extern MeasureDefaultTypeInternal _Measure_default_instance_;
class Money;
class MoneyDefaultTypeInternal;
extern MoneyDefaultTypeInternal _Money_default_instance_;
class Ordinal;
class OrdinalDefaultTypeInternal;
extern OrdinalDefaultTypeInternal _Ordinal_default_instance_;
class Telephone;
class TelephoneDefaultTypeInternal;
extern TelephoneDefaultTypeInternal _Telephone_default_instance_;
class Time;
class TimeDefaultTypeInternal;
extern TimeDefaultTypeInternal _Time_default_instance_;
}  // namespace sparrowhawk
}  // namespace speech
namespace speech {
namespace sparrowhawk {

// ===================================================================

class Cardinal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Cardinal) */ {
 public:
  Cardinal();
  virtual ~Cardinal();

  Cardinal(const Cardinal& from);

  inline Cardinal& operator=(const Cardinal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Cardinal(Cardinal&& from) noexcept
    : Cardinal() {
    *this = ::std::move(from);
  }

  inline Cardinal& operator=(Cardinal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cardinal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cardinal* internal_default_instance() {
    return reinterpret_cast<const Cardinal*>(
               &_Cardinal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Cardinal* other);
  friend void swap(Cardinal& a, Cardinal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Cardinal* New() const PROTOBUF_FINAL { return New(NULL); }

  Cardinal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Cardinal& from);
  void MergeFrom(const Cardinal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Cardinal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string field_order = 5;
  int field_order_size() const;
  void clear_field_order();
  static const int kFieldOrderFieldNumber = 5;
  const ::std::string& field_order(int index) const;
  ::std::string* mutable_field_order(int index);
  void set_field_order(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_field_order(int index, ::std::string&& value);
  #endif
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  ::std::string* add_field_order();
  void add_field_order(const ::std::string& value);
  #if LANG_CXX11
  void add_field_order(::std::string&& value);
  #endif
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // required string integer = 1;
  bool has_integer() const;
  void clear_integer();
  static const int kIntegerFieldNumber = 1;
  const ::std::string& integer() const;
  void set_integer(const ::std::string& value);
  #if LANG_CXX11
  void set_integer(::std::string&& value);
  #endif
  void set_integer(const char* value);
  void set_integer(const char* value, size_t size);
  ::std::string* mutable_integer();
  ::std::string* release_integer();
  void set_allocated_integer(::std::string* integer);

  // optional string morphosyntactic_features = 2;
  bool has_morphosyntactic_features() const;
  void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 2;
  const ::std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const ::std::string& value);
  #if LANG_CXX11
  void set_morphosyntactic_features(::std::string&& value);
  #endif
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  ::std::string* mutable_morphosyntactic_features();
  ::std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 4;
  bool has_code_switch() const;
  void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 4;
  const ::std::string& code_switch() const;
  void set_code_switch(const ::std::string& value);
  #if LANG_CXX11
  void set_code_switch(::std::string&& value);
  #endif
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  ::std::string* mutable_code_switch();
  ::std::string* release_code_switch();
  void set_allocated_code_switch(::std::string* code_switch);

  // optional bool preserve_order = 3;
  bool has_preserve_order() const;
  void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 3;
  bool preserve_order() const;
  void set_preserve_order(bool value);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Cardinal)
 private:
  void set_has_integer();
  void clear_has_integer();
  void set_has_morphosyntactic_features();
  void clear_has_morphosyntactic_features();
  void set_has_preserve_order();
  void clear_has_preserve_order();
  void set_has_code_switch();
  void clear_has_code_switch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;
  ::google::protobuf::internal::ArenaStringPtr integer_;
  ::google::protobuf::internal::ArenaStringPtr morphosyntactic_features_;
  ::google::protobuf::internal::ArenaStringPtr code_switch_;
  bool preserve_order_;
  friend struct ::protobuf_semiotic_5fclasses_2eproto::TableStruct;
  friend void ::protobuf_semiotic_5fclasses_2eproto::InitDefaultsCardinalImpl();
};
// -------------------------------------------------------------------

class Ordinal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Ordinal) */ {
 public:
  Ordinal();
  virtual ~Ordinal();

  Ordinal(const Ordinal& from);

  inline Ordinal& operator=(const Ordinal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ordinal(Ordinal&& from) noexcept
    : Ordinal() {
    *this = ::std::move(from);
  }

  inline Ordinal& operator=(Ordinal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ordinal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ordinal* internal_default_instance() {
    return reinterpret_cast<const Ordinal*>(
               &_Ordinal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Ordinal* other);
  friend void swap(Ordinal& a, Ordinal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ordinal* New() const PROTOBUF_FINAL { return New(NULL); }

  Ordinal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ordinal& from);
  void MergeFrom(const Ordinal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ordinal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string field_order = 5;
  int field_order_size() const;
  void clear_field_order();
  static const int kFieldOrderFieldNumber = 5;
  const ::std::string& field_order(int index) const;
  ::std::string* mutable_field_order(int index);
  void set_field_order(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_field_order(int index, ::std::string&& value);
  #endif
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  ::std::string* add_field_order();
  void add_field_order(const ::std::string& value);
  #if LANG_CXX11
  void add_field_order(::std::string&& value);
  #endif
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // required string integer = 1;
  bool has_integer() const;
  void clear_integer();
  static const int kIntegerFieldNumber = 1;
  const ::std::string& integer() const;
  void set_integer(const ::std::string& value);
  #if LANG_CXX11
  void set_integer(::std::string&& value);
  #endif
  void set_integer(const char* value);
  void set_integer(const char* value, size_t size);
  ::std::string* mutable_integer();
  ::std::string* release_integer();
  void set_allocated_integer(::std::string* integer);

  // optional string morphosyntactic_features = 2;
  bool has_morphosyntactic_features() const;
  void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 2;
  const ::std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const ::std::string& value);
  #if LANG_CXX11
  void set_morphosyntactic_features(::std::string&& value);
  #endif
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  ::std::string* mutable_morphosyntactic_features();
  ::std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 4;
  bool has_code_switch() const;
  void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 4;
  const ::std::string& code_switch() const;
  void set_code_switch(const ::std::string& value);
  #if LANG_CXX11
  void set_code_switch(::std::string&& value);
  #endif
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  ::std::string* mutable_code_switch();
  ::std::string* release_code_switch();
  void set_allocated_code_switch(::std::string* code_switch);

  // optional bool preserve_order = 3;
  bool has_preserve_order() const;
  void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 3;
  bool preserve_order() const;
  void set_preserve_order(bool value);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Ordinal)
 private:
  void set_has_integer();
  void clear_has_integer();
  void set_has_morphosyntactic_features();
  void clear_has_morphosyntactic_features();
  void set_has_preserve_order();
  void clear_has_preserve_order();
  void set_has_code_switch();
  void clear_has_code_switch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;
  ::google::protobuf::internal::ArenaStringPtr integer_;
  ::google::protobuf::internal::ArenaStringPtr morphosyntactic_features_;
  ::google::protobuf::internal::ArenaStringPtr code_switch_;
  bool preserve_order_;
  friend struct ::protobuf_semiotic_5fclasses_2eproto::TableStruct;
  friend void ::protobuf_semiotic_5fclasses_2eproto::InitDefaultsOrdinalImpl();
};
// -------------------------------------------------------------------

class Fraction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Fraction) */ {
 public:
  Fraction();
  virtual ~Fraction();

  Fraction(const Fraction& from);

  inline Fraction& operator=(const Fraction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fraction(Fraction&& from) noexcept
    : Fraction() {
    *this = ::std::move(from);
  }

  inline Fraction& operator=(Fraction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Fraction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fraction* internal_default_instance() {
    return reinterpret_cast<const Fraction*>(
               &_Fraction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Fraction* other);
  friend void swap(Fraction& a, Fraction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fraction* New() const PROTOBUF_FINAL { return New(NULL); }

  Fraction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Fraction& from);
  void MergeFrom(const Fraction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Fraction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string field_order = 9;
  int field_order_size() const;
  void clear_field_order();
  static const int kFieldOrderFieldNumber = 9;
  const ::std::string& field_order(int index) const;
  ::std::string* mutable_field_order(int index);
  void set_field_order(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_field_order(int index, ::std::string&& value);
  #endif
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  ::std::string* add_field_order();
  void add_field_order(const ::std::string& value);
  #if LANG_CXX11
  void add_field_order(::std::string&& value);
  #endif
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // optional string integer_part = 1;
  bool has_integer_part() const;
  void clear_integer_part();
  static const int kIntegerPartFieldNumber = 1;
  const ::std::string& integer_part() const;
  void set_integer_part(const ::std::string& value);
  #if LANG_CXX11
  void set_integer_part(::std::string&& value);
  #endif
  void set_integer_part(const char* value);
  void set_integer_part(const char* value, size_t size);
  ::std::string* mutable_integer_part();
  ::std::string* release_integer_part();
  void set_allocated_integer_part(::std::string* integer_part);

  // required string numerator = 2;
  bool has_numerator() const;
  void clear_numerator();
  static const int kNumeratorFieldNumber = 2;
  const ::std::string& numerator() const;
  void set_numerator(const ::std::string& value);
  #if LANG_CXX11
  void set_numerator(::std::string&& value);
  #endif
  void set_numerator(const char* value);
  void set_numerator(const char* value, size_t size);
  ::std::string* mutable_numerator();
  ::std::string* release_numerator();
  void set_allocated_numerator(::std::string* numerator);

  // required string denominator = 3;
  bool has_denominator() const;
  void clear_denominator();
  static const int kDenominatorFieldNumber = 3;
  const ::std::string& denominator() const;
  void set_denominator(const ::std::string& value);
  #if LANG_CXX11
  void set_denominator(::std::string&& value);
  #endif
  void set_denominator(const char* value);
  void set_denominator(const char* value, size_t size);
  ::std::string* mutable_denominator();
  ::std::string* release_denominator();
  void set_allocated_denominator(::std::string* denominator);

  // optional string morphosyntactic_features = 5;
  bool has_morphosyntactic_features() const;
  void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 5;
  const ::std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const ::std::string& value);
  #if LANG_CXX11
  void set_morphosyntactic_features(::std::string&& value);
  #endif
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  ::std::string* mutable_morphosyntactic_features();
  ::std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 7;
  bool has_code_switch() const;
  void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 7;
  const ::std::string& code_switch() const;
  void set_code_switch(const ::std::string& value);
  #if LANG_CXX11
  void set_code_switch(::std::string&& value);
  #endif
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  ::std::string* mutable_code_switch();
  ::std::string* release_code_switch();
  void set_allocated_code_switch(::std::string* code_switch);

  // optional int32 style = 4 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_style();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kStyleFieldNumber = 4;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int32 style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_style(::google::protobuf::int32 value);

  // optional bool preserve_order = 6;
  bool has_preserve_order() const;
  void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 6;
  bool preserve_order() const;
  void set_preserve_order(bool value);

  // optional bool negative = 8;
  bool has_negative() const;
  void clear_negative();
  static const int kNegativeFieldNumber = 8;
  bool negative() const;
  void set_negative(bool value);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Fraction)
 private:
  void set_has_integer_part();
  void clear_has_integer_part();
  void set_has_numerator();
  void clear_has_numerator();
  void set_has_denominator();
  void clear_has_denominator();
  void set_has_style();
  void clear_has_style();
  void set_has_morphosyntactic_features();
  void clear_has_morphosyntactic_features();
  void set_has_preserve_order();
  void clear_has_preserve_order();
  void set_has_code_switch();
  void clear_has_code_switch();
  void set_has_negative();
  void clear_has_negative();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;
  ::google::protobuf::internal::ArenaStringPtr integer_part_;
  ::google::protobuf::internal::ArenaStringPtr numerator_;
  ::google::protobuf::internal::ArenaStringPtr denominator_;
  ::google::protobuf::internal::ArenaStringPtr morphosyntactic_features_;
  ::google::protobuf::internal::ArenaStringPtr code_switch_;
  ::google::protobuf::int32 style_;
  bool preserve_order_;
  bool negative_;
  friend struct ::protobuf_semiotic_5fclasses_2eproto::TableStruct;
  friend void ::protobuf_semiotic_5fclasses_2eproto::InitDefaultsFractionImpl();
};
// -------------------------------------------------------------------

class Time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Time) */ {
 public:
  Time();
  virtual ~Time();

  Time(const Time& from);

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Time(Time&& from) noexcept
    : Time() {
    *this = ::std::move(from);
  }

  inline Time& operator=(Time&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Time* internal_default_instance() {
    return reinterpret_cast<const Time*>(
               &_Time_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Time* other);
  friend void swap(Time& a, Time& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Time* New() const PROTOBUF_FINAL { return New(NULL); }

  Time* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Time* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string field_order = 12;
  int field_order_size() const;
  void clear_field_order();
  static const int kFieldOrderFieldNumber = 12;
  const ::std::string& field_order(int index) const;
  ::std::string* mutable_field_order(int index);
  void set_field_order(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_field_order(int index, ::std::string&& value);
  #endif
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  ::std::string* add_field_order();
  void add_field_order(const ::std::string& value);
  #if LANG_CXX11
  void add_field_order(::std::string&& value);
  #endif
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // optional string suffix = 5 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_suffix() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_suffix();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kSuffixFieldNumber = 5;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::std::string& suffix() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_suffix(const ::std::string& value);
  #if LANG_CXX11
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_suffix(::std::string&& value);
  #endif
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_suffix(const char* value);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_suffix(const char* value, size_t size);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* mutable_suffix();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* release_suffix();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_suffix(::std::string* suffix);

  // optional string zone = 7;
  bool has_zone() const;
  void clear_zone();
  static const int kZoneFieldNumber = 7;
  const ::std::string& zone() const;
  void set_zone(const ::std::string& value);
  #if LANG_CXX11
  void set_zone(::std::string&& value);
  #endif
  void set_zone(const char* value);
  void set_zone(const char* value, size_t size);
  ::std::string* mutable_zone();
  ::std::string* release_zone();
  void set_allocated_zone(::std::string* zone);

  // optional string morphosyntactic_features = 9;
  bool has_morphosyntactic_features() const;
  void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 9;
  const ::std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const ::std::string& value);
  #if LANG_CXX11
  void set_morphosyntactic_features(::std::string&& value);
  #endif
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  ::std::string* mutable_morphosyntactic_features();
  ::std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 11;
  bool has_code_switch() const;
  void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 11;
  const ::std::string& code_switch() const;
  void set_code_switch(const ::std::string& value);
  #if LANG_CXX11
  void set_code_switch(::std::string&& value);
  #endif
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  ::std::string* mutable_code_switch();
  ::std::string* release_code_switch();
  void set_allocated_code_switch(::std::string* code_switch);

  // optional int32 hours = 1;
  bool has_hours() const;
  void clear_hours();
  static const int kHoursFieldNumber = 1;
  ::google::protobuf::int32 hours() const;
  void set_hours(::google::protobuf::int32 value);

  // optional int32 minutes = 2;
  bool has_minutes() const;
  void clear_minutes();
  static const int kMinutesFieldNumber = 2;
  ::google::protobuf::int32 minutes() const;
  void set_minutes(::google::protobuf::int32 value);

  // optional int32 seconds = 3 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_seconds() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_seconds();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kSecondsFieldNumber = 3;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int32 seconds() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_seconds(::google::protobuf::int32 value);

  // optional int32 style = 6 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_style();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kStyleFieldNumber = 6;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int32 style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_style(::google::protobuf::int32 value);

  // optional bool speak_period = 4;
  bool has_speak_period() const;
  void clear_speak_period();
  static const int kSpeakPeriodFieldNumber = 4;
  bool speak_period() const;
  void set_speak_period(bool value);

  // optional bool preserve_order = 10;
  bool has_preserve_order() const;
  void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 10;
  bool preserve_order() const;
  void set_preserve_order(bool value);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Time)
 private:
  void set_has_hours();
  void clear_has_hours();
  void set_has_minutes();
  void clear_has_minutes();
  void set_has_seconds();
  void clear_has_seconds();
  void set_has_speak_period();
  void clear_has_speak_period();
  void set_has_suffix();
  void clear_has_suffix();
  void set_has_style();
  void clear_has_style();
  void set_has_zone();
  void clear_has_zone();
  void set_has_morphosyntactic_features();
  void clear_has_morphosyntactic_features();
  void set_has_preserve_order();
  void clear_has_preserve_order();
  void set_has_code_switch();
  void clear_has_code_switch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;
  ::google::protobuf::internal::ArenaStringPtr suffix_;
  ::google::protobuf::internal::ArenaStringPtr zone_;
  ::google::protobuf::internal::ArenaStringPtr morphosyntactic_features_;
  ::google::protobuf::internal::ArenaStringPtr code_switch_;
  ::google::protobuf::int32 hours_;
  ::google::protobuf::int32 minutes_;
  ::google::protobuf::int32 seconds_;
  ::google::protobuf::int32 style_;
  bool speak_period_;
  bool preserve_order_;
  friend struct ::protobuf_semiotic_5fclasses_2eproto::TableStruct;
  friend void ::protobuf_semiotic_5fclasses_2eproto::InitDefaultsTimeImpl();
};
// -------------------------------------------------------------------

class Decimal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Decimal) */ {
 public:
  Decimal();
  virtual ~Decimal();

  Decimal(const Decimal& from);

  inline Decimal& operator=(const Decimal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Decimal(Decimal&& from) noexcept
    : Decimal() {
    *this = ::std::move(from);
  }

  inline Decimal& operator=(Decimal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Decimal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Decimal* internal_default_instance() {
    return reinterpret_cast<const Decimal*>(
               &_Decimal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Decimal* other);
  friend void swap(Decimal& a, Decimal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Decimal* New() const PROTOBUF_FINAL { return New(NULL); }

  Decimal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Decimal& from);
  void MergeFrom(const Decimal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Decimal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string field_order = 10;
  int field_order_size() const;
  void clear_field_order();
  static const int kFieldOrderFieldNumber = 10;
  const ::std::string& field_order(int index) const;
  ::std::string* mutable_field_order(int index);
  void set_field_order(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_field_order(int index, ::std::string&& value);
  #endif
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  ::std::string* add_field_order();
  void add_field_order(const ::std::string& value);
  #if LANG_CXX11
  void add_field_order(::std::string&& value);
  #endif
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // optional string integer_part = 2;
  bool has_integer_part() const;
  void clear_integer_part();
  static const int kIntegerPartFieldNumber = 2;
  const ::std::string& integer_part() const;
  void set_integer_part(const ::std::string& value);
  #if LANG_CXX11
  void set_integer_part(::std::string&& value);
  #endif
  void set_integer_part(const char* value);
  void set_integer_part(const char* value, size_t size);
  ::std::string* mutable_integer_part();
  ::std::string* release_integer_part();
  void set_allocated_integer_part(::std::string* integer_part);

  // optional string fractional_part = 3;
  bool has_fractional_part() const;
  void clear_fractional_part();
  static const int kFractionalPartFieldNumber = 3;
  const ::std::string& fractional_part() const;
  void set_fractional_part(const ::std::string& value);
  #if LANG_CXX11
  void set_fractional_part(::std::string&& value);
  #endif
  void set_fractional_part(const char* value);
  void set_fractional_part(const char* value, size_t size);
  ::std::string* mutable_fractional_part();
  ::std::string* release_fractional_part();
  void set_allocated_fractional_part(::std::string* fractional_part);

  // optional string quantity = 4;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  const ::std::string& quantity() const;
  void set_quantity(const ::std::string& value);
  #if LANG_CXX11
  void set_quantity(::std::string&& value);
  #endif
  void set_quantity(const char* value);
  void set_quantity(const char* value, size_t size);
  ::std::string* mutable_quantity();
  ::std::string* release_quantity();
  void set_allocated_quantity(::std::string* quantity);

  // optional string exponent = 5;
  bool has_exponent() const;
  void clear_exponent();
  static const int kExponentFieldNumber = 5;
  const ::std::string& exponent() const;
  void set_exponent(const ::std::string& value);
  #if LANG_CXX11
  void set_exponent(::std::string&& value);
  #endif
  void set_exponent(const char* value);
  void set_exponent(const char* value, size_t size);
  ::std::string* mutable_exponent();
  ::std::string* release_exponent();
  void set_allocated_exponent(::std::string* exponent);

  // optional string morphosyntactic_features = 7;
  bool has_morphosyntactic_features() const;
  void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 7;
  const ::std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const ::std::string& value);
  #if LANG_CXX11
  void set_morphosyntactic_features(::std::string&& value);
  #endif
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  ::std::string* mutable_morphosyntactic_features();
  ::std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 9;
  bool has_code_switch() const;
  void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 9;
  const ::std::string& code_switch() const;
  void set_code_switch(const ::std::string& value);
  #if LANG_CXX11
  void set_code_switch(::std::string&& value);
  #endif
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  ::std::string* mutable_code_switch();
  ::std::string* release_code_switch();
  void set_allocated_code_switch(::std::string* code_switch);

  // optional bool negative = 1;
  bool has_negative() const;
  void clear_negative();
  static const int kNegativeFieldNumber = 1;
  bool negative() const;
  void set_negative(bool value);

  // optional bool preserve_order = 8;
  bool has_preserve_order() const;
  void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 8;
  bool preserve_order() const;
  void set_preserve_order(bool value);

  // optional int32 style = 6 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_style();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kStyleFieldNumber = 6;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int32 style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_style(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Decimal)
 private:
  void set_has_negative();
  void clear_has_negative();
  void set_has_integer_part();
  void clear_has_integer_part();
  void set_has_fractional_part();
  void clear_has_fractional_part();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_exponent();
  void clear_has_exponent();
  void set_has_style();
  void clear_has_style();
  void set_has_morphosyntactic_features();
  void clear_has_morphosyntactic_features();
  void set_has_preserve_order();
  void clear_has_preserve_order();
  void set_has_code_switch();
  void clear_has_code_switch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;
  ::google::protobuf::internal::ArenaStringPtr integer_part_;
  ::google::protobuf::internal::ArenaStringPtr fractional_part_;
  ::google::protobuf::internal::ArenaStringPtr quantity_;
  ::google::protobuf::internal::ArenaStringPtr exponent_;
  ::google::protobuf::internal::ArenaStringPtr morphosyntactic_features_;
  ::google::protobuf::internal::ArenaStringPtr code_switch_;
  bool negative_;
  bool preserve_order_;
  ::google::protobuf::int32 style_;
  friend struct ::protobuf_semiotic_5fclasses_2eproto::TableStruct;
  friend void ::protobuf_semiotic_5fclasses_2eproto::InitDefaultsDecimalImpl();
};
// -------------------------------------------------------------------

class Measure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Measure) */ {
 public:
  Measure();
  virtual ~Measure();

  Measure(const Measure& from);

  inline Measure& operator=(const Measure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Measure(Measure&& from) noexcept
    : Measure() {
    *this = ::std::move(from);
  }

  inline Measure& operator=(Measure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Measure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Measure* internal_default_instance() {
    return reinterpret_cast<const Measure*>(
               &_Measure_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Measure* other);
  friend void swap(Measure& a, Measure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Measure* New() const PROTOBUF_FINAL { return New(NULL); }

  Measure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Measure& from);
  void MergeFrom(const Measure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Measure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string field_order = 9;
  int field_order_size() const;
  void clear_field_order();
  static const int kFieldOrderFieldNumber = 9;
  const ::std::string& field_order(int index) const;
  ::std::string* mutable_field_order(int index);
  void set_field_order(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_field_order(int index, ::std::string&& value);
  #endif
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  ::std::string* add_field_order();
  void add_field_order(const ::std::string& value);
  #if LANG_CXX11
  void add_field_order(::std::string&& value);
  #endif
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // optional string units = 4;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 4;
  const ::std::string& units() const;
  void set_units(const ::std::string& value);
  #if LANG_CXX11
  void set_units(::std::string&& value);
  #endif
  void set_units(const char* value);
  void set_units(const char* value, size_t size);
  ::std::string* mutable_units();
  ::std::string* release_units();
  void set_allocated_units(::std::string* units);

  // optional string morphosyntactic_features = 6;
  bool has_morphosyntactic_features() const;
  void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 6;
  const ::std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const ::std::string& value);
  #if LANG_CXX11
  void set_morphosyntactic_features(::std::string&& value);
  #endif
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  ::std::string* mutable_morphosyntactic_features();
  ::std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 8;
  bool has_code_switch() const;
  void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 8;
  const ::std::string& code_switch() const;
  void set_code_switch(const ::std::string& value);
  #if LANG_CXX11
  void set_code_switch(::std::string&& value);
  #endif
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  ::std::string* mutable_code_switch();
  ::std::string* release_code_switch();
  void set_allocated_code_switch(::std::string* code_switch);

  // optional .speech.sparrowhawk.Decimal decimal = 1;
  bool has_decimal() const;
  void clear_decimal();
  static const int kDecimalFieldNumber = 1;
  const ::speech::sparrowhawk::Decimal& decimal() const;
  ::speech::sparrowhawk::Decimal* mutable_decimal();
  ::speech::sparrowhawk::Decimal* release_decimal();
  void set_allocated_decimal(::speech::sparrowhawk::Decimal* decimal);

  // optional .speech.sparrowhawk.Fraction fraction = 2;
  bool has_fraction() const;
  void clear_fraction();
  static const int kFractionFieldNumber = 2;
  const ::speech::sparrowhawk::Fraction& fraction() const;
  ::speech::sparrowhawk::Fraction* mutable_fraction();
  ::speech::sparrowhawk::Fraction* release_fraction();
  void set_allocated_fraction(::speech::sparrowhawk::Fraction* fraction);

  // optional .speech.sparrowhawk.Cardinal cardinal = 3;
  bool has_cardinal() const;
  void clear_cardinal();
  static const int kCardinalFieldNumber = 3;
  const ::speech::sparrowhawk::Cardinal& cardinal() const;
  ::speech::sparrowhawk::Cardinal* mutable_cardinal();
  ::speech::sparrowhawk::Cardinal* release_cardinal();
  void set_allocated_cardinal(::speech::sparrowhawk::Cardinal* cardinal);

  // optional int32 style = 5 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_style();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kStyleFieldNumber = 5;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int32 style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_style(::google::protobuf::int32 value);

  // optional bool preserve_order = 7;
  bool has_preserve_order() const;
  void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 7;
  bool preserve_order() const;
  void set_preserve_order(bool value);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Measure)
 private:
  void set_has_decimal();
  void clear_has_decimal();
  void set_has_fraction();
  void clear_has_fraction();
  void set_has_cardinal();
  void clear_has_cardinal();
  void set_has_units();
  void clear_has_units();
  void set_has_style();
  void clear_has_style();
  void set_has_morphosyntactic_features();
  void clear_has_morphosyntactic_features();
  void set_has_preserve_order();
  void clear_has_preserve_order();
  void set_has_code_switch();
  void clear_has_code_switch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;
  ::google::protobuf::internal::ArenaStringPtr units_;
  ::google::protobuf::internal::ArenaStringPtr morphosyntactic_features_;
  ::google::protobuf::internal::ArenaStringPtr code_switch_;
  ::speech::sparrowhawk::Decimal* decimal_;
  ::speech::sparrowhawk::Fraction* fraction_;
  ::speech::sparrowhawk::Cardinal* cardinal_;
  ::google::protobuf::int32 style_;
  bool preserve_order_;
  friend struct ::protobuf_semiotic_5fclasses_2eproto::TableStruct;
  friend void ::protobuf_semiotic_5fclasses_2eproto::InitDefaultsMeasureImpl();
};
// -------------------------------------------------------------------

class Date : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Date) */ {
 public:
  Date();
  virtual ~Date();

  Date(const Date& from);

  inline Date& operator=(const Date& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Date(Date&& from) noexcept
    : Date() {
    *this = ::std::move(from);
  }

  inline Date& operator=(Date&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Date& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Date* internal_default_instance() {
    return reinterpret_cast<const Date*>(
               &_Date_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Date* other);
  friend void swap(Date& a, Date& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Date* New() const PROTOBUF_FINAL { return New(NULL); }

  Date* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Date& from);
  void MergeFrom(const Date& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Date* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string field_order = 12;
  int field_order_size() const;
  void clear_field_order();
  static const int kFieldOrderFieldNumber = 12;
  const ::std::string& field_order(int index) const;
  ::std::string* mutable_field_order(int index);
  void set_field_order(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_field_order(int index, ::std::string&& value);
  #endif
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  ::std::string* add_field_order();
  void add_field_order(const ::std::string& value);
  #if LANG_CXX11
  void add_field_order(::std::string&& value);
  #endif
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // optional string weekday = 1;
  bool has_weekday() const;
  void clear_weekday();
  static const int kWeekdayFieldNumber = 1;
  const ::std::string& weekday() const;
  void set_weekday(const ::std::string& value);
  #if LANG_CXX11
  void set_weekday(::std::string&& value);
  #endif
  void set_weekday(const char* value);
  void set_weekday(const char* value, size_t size);
  ::std::string* mutable_weekday();
  ::std::string* release_weekday();
  void set_allocated_weekday(::std::string* weekday);

  // optional string day = 2;
  bool has_day() const;
  void clear_day();
  static const int kDayFieldNumber = 2;
  const ::std::string& day() const;
  void set_day(const ::std::string& value);
  #if LANG_CXX11
  void set_day(::std::string&& value);
  #endif
  void set_day(const char* value);
  void set_day(const char* value, size_t size);
  ::std::string* mutable_day();
  ::std::string* release_day();
  void set_allocated_day(::std::string* day);

  // optional string month = 3;
  bool has_month() const;
  void clear_month();
  static const int kMonthFieldNumber = 3;
  const ::std::string& month() const;
  void set_month(const ::std::string& value);
  #if LANG_CXX11
  void set_month(::std::string&& value);
  #endif
  void set_month(const char* value);
  void set_month(const char* value, size_t size);
  ::std::string* mutable_month();
  ::std::string* release_month();
  void set_allocated_month(::std::string* month);

  // optional string year = 4;
  bool has_year() const;
  void clear_year();
  static const int kYearFieldNumber = 4;
  const ::std::string& year() const;
  void set_year(const ::std::string& value);
  #if LANG_CXX11
  void set_year(::std::string&& value);
  #endif
  void set_year(const char* value);
  void set_year(const char* value, size_t size);
  ::std::string* mutable_year();
  ::std::string* release_year();
  void set_allocated_year(::std::string* year);

  // optional string text = 6 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_text() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_text();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kTextFieldNumber = 6;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::std::string& text() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_text(const ::std::string& value);
  #if LANG_CXX11
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_text(::std::string&& value);
  #endif
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_text(const char* value);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_text(const char* value, size_t size);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* mutable_text();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* release_text();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_text(::std::string* text);

  // optional string era = 8;
  bool has_era() const;
  void clear_era();
  static const int kEraFieldNumber = 8;
  const ::std::string& era() const;
  void set_era(const ::std::string& value);
  #if LANG_CXX11
  void set_era(::std::string&& value);
  #endif
  void set_era(const char* value);
  void set_era(const char* value, size_t size);
  ::std::string* mutable_era();
  ::std::string* release_era();
  void set_allocated_era(::std::string* era);

  // optional string morphosyntactic_features = 9;
  bool has_morphosyntactic_features() const;
  void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 9;
  const ::std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const ::std::string& value);
  #if LANG_CXX11
  void set_morphosyntactic_features(::std::string&& value);
  #endif
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  ::std::string* mutable_morphosyntactic_features();
  ::std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 11;
  bool has_code_switch() const;
  void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 11;
  const ::std::string& code_switch() const;
  void set_code_switch(const ::std::string& value);
  #if LANG_CXX11
  void set_code_switch(::std::string&& value);
  #endif
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  ::std::string* mutable_code_switch();
  ::std::string* release_code_switch();
  void set_allocated_code_switch(::std::string* code_switch);

  // optional int32 style = 5 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_style();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kStyleFieldNumber = 5;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int32 style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_style(::google::protobuf::int32 value);

  // optional bool short_year = 7 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_short_year() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_short_year();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kShortYearFieldNumber = 7;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool short_year() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_short_year(bool value);

  // optional bool preserve_order = 10;
  bool has_preserve_order() const;
  void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 10;
  bool preserve_order() const;
  void set_preserve_order(bool value);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Date)
 private:
  void set_has_weekday();
  void clear_has_weekday();
  void set_has_day();
  void clear_has_day();
  void set_has_month();
  void clear_has_month();
  void set_has_year();
  void clear_has_year();
  void set_has_style();
  void clear_has_style();
  void set_has_text();
  void clear_has_text();
  void set_has_short_year();
  void clear_has_short_year();
  void set_has_era();
  void clear_has_era();
  void set_has_morphosyntactic_features();
  void clear_has_morphosyntactic_features();
  void set_has_preserve_order();
  void clear_has_preserve_order();
  void set_has_code_switch();
  void clear_has_code_switch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;
  ::google::protobuf::internal::ArenaStringPtr weekday_;
  ::google::protobuf::internal::ArenaStringPtr day_;
  ::google::protobuf::internal::ArenaStringPtr month_;
  ::google::protobuf::internal::ArenaStringPtr year_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr era_;
  ::google::protobuf::internal::ArenaStringPtr morphosyntactic_features_;
  ::google::protobuf::internal::ArenaStringPtr code_switch_;
  ::google::protobuf::int32 style_;
  bool short_year_;
  bool preserve_order_;
  friend struct ::protobuf_semiotic_5fclasses_2eproto::TableStruct;
  friend void ::protobuf_semiotic_5fclasses_2eproto::InitDefaultsDateImpl();
};
// -------------------------------------------------------------------

class Money : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Money) */ {
 public:
  Money();
  virtual ~Money();

  Money(const Money& from);

  inline Money& operator=(const Money& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Money(Money&& from) noexcept
    : Money() {
    *this = ::std::move(from);
  }

  inline Money& operator=(Money&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Money& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Money* internal_default_instance() {
    return reinterpret_cast<const Money*>(
               &_Money_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Money* other);
  friend void swap(Money& a, Money& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Money* New() const PROTOBUF_FINAL { return New(NULL); }

  Money* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Money& from);
  void MergeFrom(const Money& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Money* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string field_order = 8;
  int field_order_size() const;
  void clear_field_order();
  static const int kFieldOrderFieldNumber = 8;
  const ::std::string& field_order(int index) const;
  ::std::string* mutable_field_order(int index);
  void set_field_order(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_field_order(int index, ::std::string&& value);
  #endif
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  ::std::string* add_field_order();
  void add_field_order(const ::std::string& value);
  #if LANG_CXX11
  void add_field_order(::std::string&& value);
  #endif
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // required string currency = 3;
  bool has_currency() const;
  void clear_currency();
  static const int kCurrencyFieldNumber = 3;
  const ::std::string& currency() const;
  void set_currency(const ::std::string& value);
  #if LANG_CXX11
  void set_currency(::std::string&& value);
  #endif
  void set_currency(const char* value);
  void set_currency(const char* value, size_t size);
  ::std::string* mutable_currency();
  ::std::string* release_currency();
  void set_allocated_currency(::std::string* currency);

  // optional string morphosyntactic_features = 5;
  bool has_morphosyntactic_features() const;
  void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 5;
  const ::std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const ::std::string& value);
  #if LANG_CXX11
  void set_morphosyntactic_features(::std::string&& value);
  #endif
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  ::std::string* mutable_morphosyntactic_features();
  ::std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 7;
  bool has_code_switch() const;
  void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 7;
  const ::std::string& code_switch() const;
  void set_code_switch(const ::std::string& value);
  #if LANG_CXX11
  void set_code_switch(::std::string&& value);
  #endif
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  ::std::string* mutable_code_switch();
  ::std::string* release_code_switch();
  void set_allocated_code_switch(::std::string* code_switch);

  // required .speech.sparrowhawk.Decimal amount = 1;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  const ::speech::sparrowhawk::Decimal& amount() const;
  ::speech::sparrowhawk::Decimal* mutable_amount();
  ::speech::sparrowhawk::Decimal* release_amount();
  void set_allocated_amount(::speech::sparrowhawk::Decimal* amount);

  // optional int64 quantity = 2;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  ::google::protobuf::int64 quantity() const;
  void set_quantity(::google::protobuf::int64 value);

  // optional int32 style = 4 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_style();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kStyleFieldNumber = 4;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int32 style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_style(::google::protobuf::int32 value);

  // optional bool preserve_order = 6;
  bool has_preserve_order() const;
  void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 6;
  bool preserve_order() const;
  void set_preserve_order(bool value);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Money)
 private:
  void set_has_amount();
  void clear_has_amount();
  void set_has_quantity();
  void clear_has_quantity();
  void set_has_currency();
  void clear_has_currency();
  void set_has_style();
  void clear_has_style();
  void set_has_morphosyntactic_features();
  void clear_has_morphosyntactic_features();
  void set_has_preserve_order();
  void clear_has_preserve_order();
  void set_has_code_switch();
  void clear_has_code_switch();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;
  ::google::protobuf::internal::ArenaStringPtr currency_;
  ::google::protobuf::internal::ArenaStringPtr morphosyntactic_features_;
  ::google::protobuf::internal::ArenaStringPtr code_switch_;
  ::speech::sparrowhawk::Decimal* amount_;
  ::google::protobuf::int64 quantity_;
  ::google::protobuf::int32 style_;
  bool preserve_order_;
  friend struct ::protobuf_semiotic_5fclasses_2eproto::TableStruct;
  friend void ::protobuf_semiotic_5fclasses_2eproto::InitDefaultsMoneyImpl();
};
// -------------------------------------------------------------------

class Telephone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Telephone) */ {
 public:
  Telephone();
  virtual ~Telephone();

  Telephone(const Telephone& from);

  inline Telephone& operator=(const Telephone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Telephone(Telephone&& from) noexcept
    : Telephone() {
    *this = ::std::move(from);
  }

  inline Telephone& operator=(Telephone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Telephone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Telephone* internal_default_instance() {
    return reinterpret_cast<const Telephone*>(
               &_Telephone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Telephone* other);
  friend void swap(Telephone& a, Telephone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Telephone* New() const PROTOBUF_FINAL { return New(NULL); }

  Telephone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Telephone& from);
  void MergeFrom(const Telephone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Telephone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string number_part = 2;
  int number_part_size() const;
  void clear_number_part();
  static const int kNumberPartFieldNumber = 2;
  const ::std::string& number_part(int index) const;
  ::std::string* mutable_number_part(int index);
  void set_number_part(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_number_part(int index, ::std::string&& value);
  #endif
  void set_number_part(int index, const char* value);
  void set_number_part(int index, const char* value, size_t size);
  ::std::string* add_number_part();
  void add_number_part(const ::std::string& value);
  #if LANG_CXX11
  void add_number_part(::std::string&& value);
  #endif
  void add_number_part(const char* value);
  void add_number_part(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& number_part() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_number_part();

  // repeated string field_order = 8;
  int field_order_size() const;
  void clear_field_order();
  static const int kFieldOrderFieldNumber = 8;
  const ::std::string& field_order(int index) const;
  ::std::string* mutable_field_order(int index);
  void set_field_order(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_field_order(int index, ::std::string&& value);
  #endif
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  ::std::string* add_field_order();
  void add_field_order(const ::std::string& value);
  #if LANG_CXX11
  void add_field_order(::std::string&& value);
  #endif
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // optional string country_code = 1;
  bool has_country_code() const;
  void clear_country_code();
  static const int kCountryCodeFieldNumber = 1;
  const ::std::string& country_code() const;
  void set_country_code(const ::std::string& value);
  #if LANG_CXX11
  void set_country_code(::std::string&& value);
  #endif
  void set_country_code(const char* value);
  void set_country_code(const char* value, size_t size);
  ::std::string* mutable_country_code();
  ::std::string* release_country_code();
  void set_allocated_country_code(::std::string* country_code);

  // optional string extension = 3;
  bool has_extension() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 3;
  const ::std::string& extension() const;
  void set_extension(const ::std::string& value);
  #if LANG_CXX11
  void set_extension(::std::string&& value);
  #endif
  void set_extension(const char* value);
  void set_extension(const char* value, size_t size);
  ::std::string* mutable_extension();
  ::std::string* release_extension();
  void set_allocated_extension(::std::string* extension);

  // optional string morphosyntactic_features = 5;
  bool has_morphosyntactic_features() const;
  void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 5;
  const ::std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const ::std::string& value);
  #if LANG_CXX11
  void set_morphosyntactic_features(::std::string&& value);
  #endif
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  ::std::string* mutable_morphosyntactic_features();
  ::std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 7;
  bool has_code_switch() const;
  void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 7;
  const ::std::string& code_switch() const;
  void set_code_switch(const ::std::string& value);
  #if LANG_CXX11
  void set_code_switch(::std::string&& value);
  #endif
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  ::std::string* mutable_code_switch();
  ::std::string* release_code_switch();
  void set_allocated_code_switch(::std::string* code_switch);

  // optional int32 style = 4 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_style();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kStyleFieldNumber = 4;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int32 style() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_style(::google::protobuf::int32 value);

  // optional bool preserve_order = 6;
  bool has_preserve_order() const;
  void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 6;
  bool preserve_order() const;
  void set_preserve_order(bool value);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Telephone)
 private:
  void set_has_country_code();
  void clear_has_country_code();
  void set_has_extension();
  void clear_has_extension();
  void set_has_style();
  void clear_has_style();
  void set_has_morphosyntactic_features();
  void clear_has_morphosyntactic_features();
  void set_has_preserve_order();
  void clear_has_preserve_order();
  void set_has_code_switch();
  void clear_has_code_switch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> number_part_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;
  ::google::protobuf::internal::ArenaStringPtr country_code_;
  ::google::protobuf::internal::ArenaStringPtr extension_;
  ::google::protobuf::internal::ArenaStringPtr morphosyntactic_features_;
  ::google::protobuf::internal::ArenaStringPtr code_switch_;
  ::google::protobuf::int32 style_;
  bool preserve_order_;
  friend struct ::protobuf_semiotic_5fclasses_2eproto::TableStruct;
  friend void ::protobuf_semiotic_5fclasses_2eproto::InitDefaultsTelephoneImpl();
};
// -------------------------------------------------------------------

class Electronic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Electronic) */ {
 public:
  Electronic();
  virtual ~Electronic();

  Electronic(const Electronic& from);

  inline Electronic& operator=(const Electronic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Electronic(Electronic&& from) noexcept
    : Electronic() {
    *this = ::std::move(from);
  }

  inline Electronic& operator=(Electronic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Electronic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Electronic* internal_default_instance() {
    return reinterpret_cast<const Electronic*>(
               &_Electronic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Electronic* other);
  friend void swap(Electronic& a, Electronic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Electronic* New() const PROTOBUF_FINAL { return New(NULL); }

  Electronic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Electronic& from);
  void MergeFrom(const Electronic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Electronic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string field_order = 12;
  int field_order_size() const;
  void clear_field_order();
  static const int kFieldOrderFieldNumber = 12;
  const ::std::string& field_order(int index) const;
  ::std::string* mutable_field_order(int index);
  void set_field_order(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_field_order(int index, ::std::string&& value);
  #endif
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  ::std::string* add_field_order();
  void add_field_order(const ::std::string& value);
  #if LANG_CXX11
  void add_field_order(::std::string&& value);
  #endif
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& field_order() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_field_order();

  // optional string protocol = 1;
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 1;
  const ::std::string& protocol() const;
  void set_protocol(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol(::std::string&& value);
  #endif
  void set_protocol(const char* value);
  void set_protocol(const char* value, size_t size);
  ::std::string* mutable_protocol();
  ::std::string* release_protocol();
  void set_allocated_protocol(::std::string* protocol);

  // optional string username = 2;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string password = 3;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional string domain = 4;
  bool has_domain() const;
  void clear_domain();
  static const int kDomainFieldNumber = 4;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // optional string path = 6;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 6;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional string query_string = 7;
  bool has_query_string() const;
  void clear_query_string();
  static const int kQueryStringFieldNumber = 7;
  const ::std::string& query_string() const;
  void set_query_string(const ::std::string& value);
  #if LANG_CXX11
  void set_query_string(::std::string&& value);
  #endif
  void set_query_string(const char* value);
  void set_query_string(const char* value, size_t size);
  ::std::string* mutable_query_string();
  ::std::string* release_query_string();
  void set_allocated_query_string(::std::string* query_string);

  // optional string fragment_id = 8;
  bool has_fragment_id() const;
  void clear_fragment_id();
  static const int kFragmentIdFieldNumber = 8;
  const ::std::string& fragment_id() const;
  void set_fragment_id(const ::std::string& value);
  #if LANG_CXX11
  void set_fragment_id(::std::string&& value);
  #endif
  void set_fragment_id(const char* value);
  void set_fragment_id(const char* value, size_t size);
  ::std::string* mutable_fragment_id();
  ::std::string* release_fragment_id();
  void set_allocated_fragment_id(::std::string* fragment_id);

  // optional string morphosyntactic_features = 9;
  bool has_morphosyntactic_features() const;
  void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 9;
  const ::std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const ::std::string& value);
  #if LANG_CXX11
  void set_morphosyntactic_features(::std::string&& value);
  #endif
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  ::std::string* mutable_morphosyntactic_features();
  ::std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 11;
  bool has_code_switch() const;
  void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 11;
  const ::std::string& code_switch() const;
  void set_code_switch(const ::std::string& value);
  #if LANG_CXX11
  void set_code_switch(::std::string&& value);
  #endif
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  ::std::string* mutable_code_switch();
  ::std::string* release_code_switch();
  void set_allocated_code_switch(::std::string* code_switch);

  // optional int32 port = 5;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 5;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // optional bool preserve_order = 10;
  bool has_preserve_order() const;
  void clear_preserve_order();
  static const int kPreserveOrderFieldNumber = 10;
  bool preserve_order() const;
  void set_preserve_order(bool value);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Electronic)
 private:
  void set_has_protocol();
  void clear_has_protocol();
  void set_has_username();
  void clear_has_username();
  void set_has_password();
  void clear_has_password();
  void set_has_domain();
  void clear_has_domain();
  void set_has_port();
  void clear_has_port();
  void set_has_path();
  void clear_has_path();
  void set_has_query_string();
  void clear_has_query_string();
  void set_has_fragment_id();
  void clear_has_fragment_id();
  void set_has_morphosyntactic_features();
  void clear_has_morphosyntactic_features();
  void set_has_preserve_order();
  void clear_has_preserve_order();
  void set_has_code_switch();
  void clear_has_code_switch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> field_order_;
  ::google::protobuf::internal::ArenaStringPtr protocol_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr query_string_;
  ::google::protobuf::internal::ArenaStringPtr fragment_id_;
  ::google::protobuf::internal::ArenaStringPtr morphosyntactic_features_;
  ::google::protobuf::internal::ArenaStringPtr code_switch_;
  ::google::protobuf::int32 port_;
  bool preserve_order_;
  friend struct ::protobuf_semiotic_5fclasses_2eproto::TableStruct;
  friend void ::protobuf_semiotic_5fclasses_2eproto::InitDefaultsElectronicImpl();
};
// -------------------------------------------------------------------

class Connector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Connector) */ {
 public:
  Connector();
  virtual ~Connector();

  Connector(const Connector& from);

  inline Connector& operator=(const Connector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Connector(Connector&& from) noexcept
    : Connector() {
    *this = ::std::move(from);
  }

  inline Connector& operator=(Connector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Connector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Connector* internal_default_instance() {
    return reinterpret_cast<const Connector*>(
               &_Connector_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Connector* other);
  friend void swap(Connector& a, Connector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Connector* New() const PROTOBUF_FINAL { return New(NULL); }

  Connector* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Connector& from);
  void MergeFrom(const Connector& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Connector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string morphosyntactic_features = 2;
  bool has_morphosyntactic_features() const;
  void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 2;
  const ::std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const ::std::string& value);
  #if LANG_CXX11
  void set_morphosyntactic_features(::std::string&& value);
  #endif
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  ::std::string* mutable_morphosyntactic_features();
  ::std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 3;
  bool has_code_switch() const;
  void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 3;
  const ::std::string& code_switch() const;
  void set_code_switch(const ::std::string& value);
  #if LANG_CXX11
  void set_code_switch(::std::string&& value);
  #endif
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  ::std::string* mutable_code_switch();
  ::std::string* release_code_switch();
  void set_allocated_code_switch(::std::string* code_switch);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Connector)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_morphosyntactic_features();
  void clear_has_morphosyntactic_features();
  void set_has_code_switch();
  void clear_has_code_switch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr morphosyntactic_features_;
  ::google::protobuf::internal::ArenaStringPtr code_switch_;
  friend struct ::protobuf_semiotic_5fclasses_2eproto::TableStruct;
  friend void ::protobuf_semiotic_5fclasses_2eproto::InitDefaultsConnectorImpl();
};
// -------------------------------------------------------------------

class Abbreviation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Abbreviation) */ {
 public:
  Abbreviation();
  virtual ~Abbreviation();

  Abbreviation(const Abbreviation& from);

  inline Abbreviation& operator=(const Abbreviation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Abbreviation(Abbreviation&& from) noexcept
    : Abbreviation() {
    *this = ::std::move(from);
  }

  inline Abbreviation& operator=(Abbreviation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Abbreviation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Abbreviation* internal_default_instance() {
    return reinterpret_cast<const Abbreviation*>(
               &_Abbreviation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Abbreviation* other);
  friend void swap(Abbreviation& a, Abbreviation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Abbreviation* New() const PROTOBUF_FINAL { return New(NULL); }

  Abbreviation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Abbreviation& from);
  void MergeFrom(const Abbreviation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Abbreviation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional string morphosyntactic_features = 2;
  bool has_morphosyntactic_features() const;
  void clear_morphosyntactic_features();
  static const int kMorphosyntacticFeaturesFieldNumber = 2;
  const ::std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const ::std::string& value);
  #if LANG_CXX11
  void set_morphosyntactic_features(::std::string&& value);
  #endif
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  ::std::string* mutable_morphosyntactic_features();
  ::std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features);

  // optional string code_switch = 3;
  bool has_code_switch() const;
  void clear_code_switch();
  static const int kCodeSwitchFieldNumber = 3;
  const ::std::string& code_switch() const;
  void set_code_switch(const ::std::string& value);
  #if LANG_CXX11
  void set_code_switch(::std::string&& value);
  #endif
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  ::std::string* mutable_code_switch();
  ::std::string* release_code_switch();
  void set_allocated_code_switch(::std::string* code_switch);

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Abbreviation)
 private:
  void set_has_text();
  void clear_has_text();
  void set_has_morphosyntactic_features();
  void clear_has_morphosyntactic_features();
  void set_has_code_switch();
  void clear_has_code_switch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr morphosyntactic_features_;
  ::google::protobuf::internal::ArenaStringPtr code_switch_;
  friend struct ::protobuf_semiotic_5fclasses_2eproto::TableStruct;
  friend void ::protobuf_semiotic_5fclasses_2eproto::InitDefaultsAbbreviationImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Cardinal

// required string integer = 1;
inline bool Cardinal::has_integer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cardinal::set_has_integer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cardinal::clear_has_integer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cardinal::clear_integer() {
  integer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_integer();
}
inline const ::std::string& Cardinal::integer() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Cardinal.integer)
  return integer_.GetNoArena();
}
inline void Cardinal::set_integer(const ::std::string& value) {
  set_has_integer();
  integer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Cardinal.integer)
}
#if LANG_CXX11
inline void Cardinal::set_integer(::std::string&& value) {
  set_has_integer();
  integer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Cardinal.integer)
}
#endif
inline void Cardinal::set_integer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_integer();
  integer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Cardinal.integer)
}
inline void Cardinal::set_integer(const char* value, size_t size) {
  set_has_integer();
  integer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Cardinal.integer)
}
inline ::std::string* Cardinal::mutable_integer() {
  set_has_integer();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Cardinal.integer)
  return integer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Cardinal::release_integer() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Cardinal.integer)
  clear_has_integer();
  return integer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Cardinal::set_allocated_integer(::std::string* integer) {
  if (integer != NULL) {
    set_has_integer();
  } else {
    clear_has_integer();
  }
  integer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), integer);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Cardinal.integer)
}

// optional string morphosyntactic_features = 2;
inline bool Cardinal::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cardinal::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cardinal::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cardinal::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Cardinal::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Cardinal.morphosyntactic_features)
  return morphosyntactic_features_.GetNoArena();
}
inline void Cardinal::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Cardinal.morphosyntactic_features)
}
#if LANG_CXX11
inline void Cardinal::set_morphosyntactic_features(::std::string&& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Cardinal.morphosyntactic_features)
}
#endif
inline void Cardinal::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Cardinal.morphosyntactic_features)
}
inline void Cardinal::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Cardinal.morphosyntactic_features)
}
inline ::std::string* Cardinal::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Cardinal.morphosyntactic_features)
  return morphosyntactic_features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Cardinal::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Cardinal.morphosyntactic_features)
  clear_has_morphosyntactic_features();
  return morphosyntactic_features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Cardinal::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features != NULL) {
    set_has_morphosyntactic_features();
  } else {
    clear_has_morphosyntactic_features();
  }
  morphosyntactic_features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Cardinal.morphosyntactic_features)
}

// optional bool preserve_order = 3;
inline bool Cardinal::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Cardinal::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Cardinal::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Cardinal::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Cardinal::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Cardinal.preserve_order)
  return preserve_order_;
}
inline void Cardinal::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Cardinal.preserve_order)
}

// optional string code_switch = 4;
inline bool Cardinal::has_code_switch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cardinal::set_has_code_switch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cardinal::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cardinal::clear_code_switch() {
  code_switch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code_switch();
}
inline const ::std::string& Cardinal::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Cardinal.code_switch)
  return code_switch_.GetNoArena();
}
inline void Cardinal::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Cardinal.code_switch)
}
#if LANG_CXX11
inline void Cardinal::set_code_switch(::std::string&& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Cardinal.code_switch)
}
#endif
inline void Cardinal::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Cardinal.code_switch)
}
inline void Cardinal::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Cardinal.code_switch)
}
inline ::std::string* Cardinal::mutable_code_switch() {
  set_has_code_switch();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Cardinal.code_switch)
  return code_switch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Cardinal::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Cardinal.code_switch)
  clear_has_code_switch();
  return code_switch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Cardinal::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch != NULL) {
    set_has_code_switch();
  } else {
    clear_has_code_switch();
  }
  code_switch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code_switch);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Cardinal.code_switch)
}

// repeated string field_order = 5;
inline int Cardinal::field_order_size() const {
  return field_order_.size();
}
inline void Cardinal::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Cardinal::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Cardinal.field_order)
  return field_order_.Get(index);
}
inline ::std::string* Cardinal::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Cardinal.field_order)
  return field_order_.Mutable(index);
}
inline void Cardinal::set_field_order(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Cardinal.field_order)
  field_order_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Cardinal::set_field_order(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Cardinal.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Cardinal::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Cardinal.field_order)
}
inline void Cardinal::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Cardinal.field_order)
}
inline ::std::string* Cardinal::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Cardinal.field_order)
  return field_order_.Add();
}
inline void Cardinal::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Cardinal.field_order)
}
#if LANG_CXX11
inline void Cardinal::add_field_order(::std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Cardinal.field_order)
}
#endif
inline void Cardinal::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Cardinal.field_order)
}
inline void Cardinal::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Cardinal.field_order)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Cardinal::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Cardinal.field_order)
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Cardinal::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Cardinal.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Ordinal

// required string integer = 1;
inline bool Ordinal::has_integer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ordinal::set_has_integer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ordinal::clear_has_integer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ordinal::clear_integer() {
  integer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_integer();
}
inline const ::std::string& Ordinal::integer() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Ordinal.integer)
  return integer_.GetNoArena();
}
inline void Ordinal::set_integer(const ::std::string& value) {
  set_has_integer();
  integer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Ordinal.integer)
}
#if LANG_CXX11
inline void Ordinal::set_integer(::std::string&& value) {
  set_has_integer();
  integer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Ordinal.integer)
}
#endif
inline void Ordinal::set_integer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_integer();
  integer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Ordinal.integer)
}
inline void Ordinal::set_integer(const char* value, size_t size) {
  set_has_integer();
  integer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Ordinal.integer)
}
inline ::std::string* Ordinal::mutable_integer() {
  set_has_integer();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Ordinal.integer)
  return integer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ordinal::release_integer() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Ordinal.integer)
  clear_has_integer();
  return integer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ordinal::set_allocated_integer(::std::string* integer) {
  if (integer != NULL) {
    set_has_integer();
  } else {
    clear_has_integer();
  }
  integer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), integer);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Ordinal.integer)
}

// optional string morphosyntactic_features = 2;
inline bool Ordinal::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ordinal::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ordinal::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ordinal::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Ordinal::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Ordinal.morphosyntactic_features)
  return morphosyntactic_features_.GetNoArena();
}
inline void Ordinal::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Ordinal.morphosyntactic_features)
}
#if LANG_CXX11
inline void Ordinal::set_morphosyntactic_features(::std::string&& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Ordinal.morphosyntactic_features)
}
#endif
inline void Ordinal::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Ordinal.morphosyntactic_features)
}
inline void Ordinal::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Ordinal.morphosyntactic_features)
}
inline ::std::string* Ordinal::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Ordinal.morphosyntactic_features)
  return morphosyntactic_features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ordinal::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Ordinal.morphosyntactic_features)
  clear_has_morphosyntactic_features();
  return morphosyntactic_features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ordinal::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features != NULL) {
    set_has_morphosyntactic_features();
  } else {
    clear_has_morphosyntactic_features();
  }
  morphosyntactic_features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Ordinal.morphosyntactic_features)
}

// optional bool preserve_order = 3;
inline bool Ordinal::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ordinal::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ordinal::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ordinal::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Ordinal::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Ordinal.preserve_order)
  return preserve_order_;
}
inline void Ordinal::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Ordinal.preserve_order)
}

// optional string code_switch = 4;
inline bool Ordinal::has_code_switch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ordinal::set_has_code_switch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ordinal::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ordinal::clear_code_switch() {
  code_switch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code_switch();
}
inline const ::std::string& Ordinal::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Ordinal.code_switch)
  return code_switch_.GetNoArena();
}
inline void Ordinal::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Ordinal.code_switch)
}
#if LANG_CXX11
inline void Ordinal::set_code_switch(::std::string&& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Ordinal.code_switch)
}
#endif
inline void Ordinal::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Ordinal.code_switch)
}
inline void Ordinal::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Ordinal.code_switch)
}
inline ::std::string* Ordinal::mutable_code_switch() {
  set_has_code_switch();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Ordinal.code_switch)
  return code_switch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ordinal::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Ordinal.code_switch)
  clear_has_code_switch();
  return code_switch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ordinal::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch != NULL) {
    set_has_code_switch();
  } else {
    clear_has_code_switch();
  }
  code_switch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code_switch);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Ordinal.code_switch)
}

// repeated string field_order = 5;
inline int Ordinal::field_order_size() const {
  return field_order_.size();
}
inline void Ordinal::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Ordinal::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Ordinal.field_order)
  return field_order_.Get(index);
}
inline ::std::string* Ordinal::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Ordinal.field_order)
  return field_order_.Mutable(index);
}
inline void Ordinal::set_field_order(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Ordinal.field_order)
  field_order_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Ordinal::set_field_order(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Ordinal.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Ordinal::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Ordinal.field_order)
}
inline void Ordinal::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Ordinal.field_order)
}
inline ::std::string* Ordinal::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Ordinal.field_order)
  return field_order_.Add();
}
inline void Ordinal::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Ordinal.field_order)
}
#if LANG_CXX11
inline void Ordinal::add_field_order(::std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Ordinal.field_order)
}
#endif
inline void Ordinal::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Ordinal.field_order)
}
inline void Ordinal::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Ordinal.field_order)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Ordinal::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Ordinal.field_order)
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Ordinal::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Ordinal.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Fraction

// optional string integer_part = 1;
inline bool Fraction::has_integer_part() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fraction::set_has_integer_part() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Fraction::clear_has_integer_part() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Fraction::clear_integer_part() {
  integer_part_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_integer_part();
}
inline const ::std::string& Fraction::integer_part() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.integer_part)
  return integer_part_.GetNoArena();
}
inline void Fraction::set_integer_part(const ::std::string& value) {
  set_has_integer_part();
  integer_part_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.integer_part)
}
#if LANG_CXX11
inline void Fraction::set_integer_part(::std::string&& value) {
  set_has_integer_part();
  integer_part_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Fraction.integer_part)
}
#endif
inline void Fraction::set_integer_part(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_integer_part();
  integer_part_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Fraction.integer_part)
}
inline void Fraction::set_integer_part(const char* value, size_t size) {
  set_has_integer_part();
  integer_part_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Fraction.integer_part)
}
inline ::std::string* Fraction::mutable_integer_part() {
  set_has_integer_part();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Fraction.integer_part)
  return integer_part_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fraction::release_integer_part() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Fraction.integer_part)
  clear_has_integer_part();
  return integer_part_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fraction::set_allocated_integer_part(::std::string* integer_part) {
  if (integer_part != NULL) {
    set_has_integer_part();
  } else {
    clear_has_integer_part();
  }
  integer_part_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), integer_part);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Fraction.integer_part)
}

// required string numerator = 2;
inline bool Fraction::has_numerator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fraction::set_has_numerator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Fraction::clear_has_numerator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Fraction::clear_numerator() {
  numerator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_numerator();
}
inline const ::std::string& Fraction::numerator() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.numerator)
  return numerator_.GetNoArena();
}
inline void Fraction::set_numerator(const ::std::string& value) {
  set_has_numerator();
  numerator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.numerator)
}
#if LANG_CXX11
inline void Fraction::set_numerator(::std::string&& value) {
  set_has_numerator();
  numerator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Fraction.numerator)
}
#endif
inline void Fraction::set_numerator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_numerator();
  numerator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Fraction.numerator)
}
inline void Fraction::set_numerator(const char* value, size_t size) {
  set_has_numerator();
  numerator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Fraction.numerator)
}
inline ::std::string* Fraction::mutable_numerator() {
  set_has_numerator();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Fraction.numerator)
  return numerator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fraction::release_numerator() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Fraction.numerator)
  clear_has_numerator();
  return numerator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fraction::set_allocated_numerator(::std::string* numerator) {
  if (numerator != NULL) {
    set_has_numerator();
  } else {
    clear_has_numerator();
  }
  numerator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), numerator);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Fraction.numerator)
}

// required string denominator = 3;
inline bool Fraction::has_denominator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fraction::set_has_denominator() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Fraction::clear_has_denominator() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Fraction::clear_denominator() {
  denominator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_denominator();
}
inline const ::std::string& Fraction::denominator() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.denominator)
  return denominator_.GetNoArena();
}
inline void Fraction::set_denominator(const ::std::string& value) {
  set_has_denominator();
  denominator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.denominator)
}
#if LANG_CXX11
inline void Fraction::set_denominator(::std::string&& value) {
  set_has_denominator();
  denominator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Fraction.denominator)
}
#endif
inline void Fraction::set_denominator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_denominator();
  denominator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Fraction.denominator)
}
inline void Fraction::set_denominator(const char* value, size_t size) {
  set_has_denominator();
  denominator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Fraction.denominator)
}
inline ::std::string* Fraction::mutable_denominator() {
  set_has_denominator();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Fraction.denominator)
  return denominator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fraction::release_denominator() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Fraction.denominator)
  clear_has_denominator();
  return denominator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fraction::set_allocated_denominator(::std::string* denominator) {
  if (denominator != NULL) {
    set_has_denominator();
  } else {
    clear_has_denominator();
  }
  denominator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), denominator);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Fraction.denominator)
}

// optional int32 style = 4 [deprecated = true];
inline bool Fraction::has_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Fraction::set_has_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Fraction::clear_has_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Fraction::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Fraction::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.style)
  return style_;
}
inline void Fraction::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.style)
}

// optional string morphosyntactic_features = 5;
inline bool Fraction::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fraction::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Fraction::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Fraction::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Fraction::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.morphosyntactic_features)
  return morphosyntactic_features_.GetNoArena();
}
inline void Fraction::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.morphosyntactic_features)
}
#if LANG_CXX11
inline void Fraction::set_morphosyntactic_features(::std::string&& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Fraction.morphosyntactic_features)
}
#endif
inline void Fraction::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Fraction.morphosyntactic_features)
}
inline void Fraction::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Fraction.morphosyntactic_features)
}
inline ::std::string* Fraction::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Fraction.morphosyntactic_features)
  return morphosyntactic_features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fraction::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Fraction.morphosyntactic_features)
  clear_has_morphosyntactic_features();
  return morphosyntactic_features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fraction::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features != NULL) {
    set_has_morphosyntactic_features();
  } else {
    clear_has_morphosyntactic_features();
  }
  morphosyntactic_features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Fraction.morphosyntactic_features)
}

// optional bool preserve_order = 6;
inline bool Fraction::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Fraction::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Fraction::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Fraction::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Fraction::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.preserve_order)
  return preserve_order_;
}
inline void Fraction::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.preserve_order)
}

// optional string code_switch = 7;
inline bool Fraction::has_code_switch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Fraction::set_has_code_switch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Fraction::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Fraction::clear_code_switch() {
  code_switch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code_switch();
}
inline const ::std::string& Fraction::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.code_switch)
  return code_switch_.GetNoArena();
}
inline void Fraction::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.code_switch)
}
#if LANG_CXX11
inline void Fraction::set_code_switch(::std::string&& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Fraction.code_switch)
}
#endif
inline void Fraction::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Fraction.code_switch)
}
inline void Fraction::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Fraction.code_switch)
}
inline ::std::string* Fraction::mutable_code_switch() {
  set_has_code_switch();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Fraction.code_switch)
  return code_switch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fraction::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Fraction.code_switch)
  clear_has_code_switch();
  return code_switch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fraction::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch != NULL) {
    set_has_code_switch();
  } else {
    clear_has_code_switch();
  }
  code_switch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code_switch);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Fraction.code_switch)
}

// optional bool negative = 8;
inline bool Fraction::has_negative() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Fraction::set_has_negative() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Fraction::clear_has_negative() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Fraction::clear_negative() {
  negative_ = false;
  clear_has_negative();
}
inline bool Fraction::negative() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.negative)
  return negative_;
}
inline void Fraction::set_negative(bool value) {
  set_has_negative();
  negative_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.negative)
}

// repeated string field_order = 9;
inline int Fraction::field_order_size() const {
  return field_order_.size();
}
inline void Fraction::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Fraction::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.field_order)
  return field_order_.Get(index);
}
inline ::std::string* Fraction::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Fraction.field_order)
  return field_order_.Mutable(index);
}
inline void Fraction::set_field_order(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.field_order)
  field_order_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Fraction::set_field_order(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Fraction::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Fraction.field_order)
}
inline void Fraction::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Fraction.field_order)
}
inline ::std::string* Fraction::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Fraction.field_order)
  return field_order_.Add();
}
inline void Fraction::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Fraction.field_order)
}
#if LANG_CXX11
inline void Fraction::add_field_order(::std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Fraction.field_order)
}
#endif
inline void Fraction::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Fraction.field_order)
}
inline void Fraction::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Fraction.field_order)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Fraction::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Fraction.field_order)
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Fraction::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Fraction.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Time

// optional int32 hours = 1;
inline bool Time::has_hours() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Time::set_has_hours() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Time::clear_has_hours() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Time::clear_hours() {
  hours_ = 0;
  clear_has_hours();
}
inline ::google::protobuf::int32 Time::hours() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.hours)
  return hours_;
}
inline void Time::set_hours(::google::protobuf::int32 value) {
  set_has_hours();
  hours_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.hours)
}

// optional int32 minutes = 2;
inline bool Time::has_minutes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Time::set_has_minutes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Time::clear_has_minutes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Time::clear_minutes() {
  minutes_ = 0;
  clear_has_minutes();
}
inline ::google::protobuf::int32 Time::minutes() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.minutes)
  return minutes_;
}
inline void Time::set_minutes(::google::protobuf::int32 value) {
  set_has_minutes();
  minutes_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.minutes)
}

// optional int32 seconds = 3 [deprecated = true];
inline bool Time::has_seconds() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Time::set_has_seconds() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Time::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Time::clear_seconds() {
  seconds_ = 0;
  clear_has_seconds();
}
inline ::google::protobuf::int32 Time::seconds() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.seconds)
  return seconds_;
}
inline void Time::set_seconds(::google::protobuf::int32 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.seconds)
}

// optional bool speak_period = 4;
inline bool Time::has_speak_period() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Time::set_has_speak_period() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Time::clear_has_speak_period() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Time::clear_speak_period() {
  speak_period_ = false;
  clear_has_speak_period();
}
inline bool Time::speak_period() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.speak_period)
  return speak_period_;
}
inline void Time::set_speak_period(bool value) {
  set_has_speak_period();
  speak_period_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.speak_period)
}

// optional string suffix = 5 [deprecated = true];
inline bool Time::has_suffix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Time::set_has_suffix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Time::clear_has_suffix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Time::clear_suffix() {
  suffix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_suffix();
}
inline const ::std::string& Time::suffix() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.suffix)
  return suffix_.GetNoArena();
}
inline void Time::set_suffix(const ::std::string& value) {
  set_has_suffix();
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.suffix)
}
#if LANG_CXX11
inline void Time::set_suffix(::std::string&& value) {
  set_has_suffix();
  suffix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Time.suffix)
}
#endif
inline void Time::set_suffix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_suffix();
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Time.suffix)
}
inline void Time::set_suffix(const char* value, size_t size) {
  set_has_suffix();
  suffix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Time.suffix)
}
inline ::std::string* Time::mutable_suffix() {
  set_has_suffix();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Time.suffix)
  return suffix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Time::release_suffix() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Time.suffix)
  clear_has_suffix();
  return suffix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Time::set_allocated_suffix(::std::string* suffix) {
  if (suffix != NULL) {
    set_has_suffix();
  } else {
    clear_has_suffix();
  }
  suffix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), suffix);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Time.suffix)
}

// optional int32 style = 6 [deprecated = true];
inline bool Time::has_style() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Time::set_has_style() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Time::clear_has_style() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Time::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Time::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.style)
  return style_;
}
inline void Time::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.style)
}

// optional string zone = 7;
inline bool Time::has_zone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Time::set_has_zone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Time::clear_has_zone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Time::clear_zone() {
  zone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_zone();
}
inline const ::std::string& Time::zone() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.zone)
  return zone_.GetNoArena();
}
inline void Time::set_zone(const ::std::string& value) {
  set_has_zone();
  zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.zone)
}
#if LANG_CXX11
inline void Time::set_zone(::std::string&& value) {
  set_has_zone();
  zone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Time.zone)
}
#endif
inline void Time::set_zone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_zone();
  zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Time.zone)
}
inline void Time::set_zone(const char* value, size_t size) {
  set_has_zone();
  zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Time.zone)
}
inline ::std::string* Time::mutable_zone() {
  set_has_zone();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Time.zone)
  return zone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Time::release_zone() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Time.zone)
  clear_has_zone();
  return zone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Time::set_allocated_zone(::std::string* zone) {
  if (zone != NULL) {
    set_has_zone();
  } else {
    clear_has_zone();
  }
  zone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), zone);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Time.zone)
}

// optional string morphosyntactic_features = 9;
inline bool Time::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Time::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Time::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Time::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Time::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.morphosyntactic_features)
  return morphosyntactic_features_.GetNoArena();
}
inline void Time::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.morphosyntactic_features)
}
#if LANG_CXX11
inline void Time::set_morphosyntactic_features(::std::string&& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Time.morphosyntactic_features)
}
#endif
inline void Time::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Time.morphosyntactic_features)
}
inline void Time::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Time.morphosyntactic_features)
}
inline ::std::string* Time::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Time.morphosyntactic_features)
  return morphosyntactic_features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Time::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Time.morphosyntactic_features)
  clear_has_morphosyntactic_features();
  return morphosyntactic_features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Time::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features != NULL) {
    set_has_morphosyntactic_features();
  } else {
    clear_has_morphosyntactic_features();
  }
  morphosyntactic_features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Time.morphosyntactic_features)
}

// optional bool preserve_order = 10;
inline bool Time::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Time::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Time::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Time::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Time::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.preserve_order)
  return preserve_order_;
}
inline void Time::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.preserve_order)
}

// optional string code_switch = 11;
inline bool Time::has_code_switch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Time::set_has_code_switch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Time::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Time::clear_code_switch() {
  code_switch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code_switch();
}
inline const ::std::string& Time::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.code_switch)
  return code_switch_.GetNoArena();
}
inline void Time::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.code_switch)
}
#if LANG_CXX11
inline void Time::set_code_switch(::std::string&& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Time.code_switch)
}
#endif
inline void Time::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Time.code_switch)
}
inline void Time::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Time.code_switch)
}
inline ::std::string* Time::mutable_code_switch() {
  set_has_code_switch();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Time.code_switch)
  return code_switch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Time::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Time.code_switch)
  clear_has_code_switch();
  return code_switch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Time::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch != NULL) {
    set_has_code_switch();
  } else {
    clear_has_code_switch();
  }
  code_switch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code_switch);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Time.code_switch)
}

// repeated string field_order = 12;
inline int Time::field_order_size() const {
  return field_order_.size();
}
inline void Time::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Time::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.field_order)
  return field_order_.Get(index);
}
inline ::std::string* Time::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Time.field_order)
  return field_order_.Mutable(index);
}
inline void Time::set_field_order(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.field_order)
  field_order_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Time::set_field_order(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Time::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Time.field_order)
}
inline void Time::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Time.field_order)
}
inline ::std::string* Time::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Time.field_order)
  return field_order_.Add();
}
inline void Time::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Time.field_order)
}
#if LANG_CXX11
inline void Time::add_field_order(::std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Time.field_order)
}
#endif
inline void Time::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Time.field_order)
}
inline void Time::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Time.field_order)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Time::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Time.field_order)
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Time::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Time.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Decimal

// optional bool negative = 1;
inline bool Decimal::has_negative() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Decimal::set_has_negative() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Decimal::clear_has_negative() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Decimal::clear_negative() {
  negative_ = false;
  clear_has_negative();
}
inline bool Decimal::negative() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.negative)
  return negative_;
}
inline void Decimal::set_negative(bool value) {
  set_has_negative();
  negative_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.negative)
}

// optional string integer_part = 2;
inline bool Decimal::has_integer_part() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Decimal::set_has_integer_part() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Decimal::clear_has_integer_part() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Decimal::clear_integer_part() {
  integer_part_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_integer_part();
}
inline const ::std::string& Decimal::integer_part() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.integer_part)
  return integer_part_.GetNoArena();
}
inline void Decimal::set_integer_part(const ::std::string& value) {
  set_has_integer_part();
  integer_part_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.integer_part)
}
#if LANG_CXX11
inline void Decimal::set_integer_part(::std::string&& value) {
  set_has_integer_part();
  integer_part_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Decimal.integer_part)
}
#endif
inline void Decimal::set_integer_part(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_integer_part();
  integer_part_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.integer_part)
}
inline void Decimal::set_integer_part(const char* value, size_t size) {
  set_has_integer_part();
  integer_part_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.integer_part)
}
inline ::std::string* Decimal::mutable_integer_part() {
  set_has_integer_part();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.integer_part)
  return integer_part_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Decimal::release_integer_part() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Decimal.integer_part)
  clear_has_integer_part();
  return integer_part_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Decimal::set_allocated_integer_part(::std::string* integer_part) {
  if (integer_part != NULL) {
    set_has_integer_part();
  } else {
    clear_has_integer_part();
  }
  integer_part_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), integer_part);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Decimal.integer_part)
}

// optional string fractional_part = 3;
inline bool Decimal::has_fractional_part() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Decimal::set_has_fractional_part() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Decimal::clear_has_fractional_part() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Decimal::clear_fractional_part() {
  fractional_part_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fractional_part();
}
inline const ::std::string& Decimal::fractional_part() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.fractional_part)
  return fractional_part_.GetNoArena();
}
inline void Decimal::set_fractional_part(const ::std::string& value) {
  set_has_fractional_part();
  fractional_part_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.fractional_part)
}
#if LANG_CXX11
inline void Decimal::set_fractional_part(::std::string&& value) {
  set_has_fractional_part();
  fractional_part_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Decimal.fractional_part)
}
#endif
inline void Decimal::set_fractional_part(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fractional_part();
  fractional_part_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.fractional_part)
}
inline void Decimal::set_fractional_part(const char* value, size_t size) {
  set_has_fractional_part();
  fractional_part_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.fractional_part)
}
inline ::std::string* Decimal::mutable_fractional_part() {
  set_has_fractional_part();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.fractional_part)
  return fractional_part_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Decimal::release_fractional_part() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Decimal.fractional_part)
  clear_has_fractional_part();
  return fractional_part_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Decimal::set_allocated_fractional_part(::std::string* fractional_part) {
  if (fractional_part != NULL) {
    set_has_fractional_part();
  } else {
    clear_has_fractional_part();
  }
  fractional_part_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fractional_part);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Decimal.fractional_part)
}

// optional string quantity = 4;
inline bool Decimal::has_quantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Decimal::set_has_quantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Decimal::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Decimal::clear_quantity() {
  quantity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_quantity();
}
inline const ::std::string& Decimal::quantity() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.quantity)
  return quantity_.GetNoArena();
}
inline void Decimal::set_quantity(const ::std::string& value) {
  set_has_quantity();
  quantity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.quantity)
}
#if LANG_CXX11
inline void Decimal::set_quantity(::std::string&& value) {
  set_has_quantity();
  quantity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Decimal.quantity)
}
#endif
inline void Decimal::set_quantity(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_quantity();
  quantity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.quantity)
}
inline void Decimal::set_quantity(const char* value, size_t size) {
  set_has_quantity();
  quantity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.quantity)
}
inline ::std::string* Decimal::mutable_quantity() {
  set_has_quantity();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.quantity)
  return quantity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Decimal::release_quantity() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Decimal.quantity)
  clear_has_quantity();
  return quantity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Decimal::set_allocated_quantity(::std::string* quantity) {
  if (quantity != NULL) {
    set_has_quantity();
  } else {
    clear_has_quantity();
  }
  quantity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), quantity);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Decimal.quantity)
}

// optional string exponent = 5;
inline bool Decimal::has_exponent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Decimal::set_has_exponent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Decimal::clear_has_exponent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Decimal::clear_exponent() {
  exponent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exponent();
}
inline const ::std::string& Decimal::exponent() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.exponent)
  return exponent_.GetNoArena();
}
inline void Decimal::set_exponent(const ::std::string& value) {
  set_has_exponent();
  exponent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.exponent)
}
#if LANG_CXX11
inline void Decimal::set_exponent(::std::string&& value) {
  set_has_exponent();
  exponent_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Decimal.exponent)
}
#endif
inline void Decimal::set_exponent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exponent();
  exponent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.exponent)
}
inline void Decimal::set_exponent(const char* value, size_t size) {
  set_has_exponent();
  exponent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.exponent)
}
inline ::std::string* Decimal::mutable_exponent() {
  set_has_exponent();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.exponent)
  return exponent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Decimal::release_exponent() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Decimal.exponent)
  clear_has_exponent();
  return exponent_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Decimal::set_allocated_exponent(::std::string* exponent) {
  if (exponent != NULL) {
    set_has_exponent();
  } else {
    clear_has_exponent();
  }
  exponent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exponent);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Decimal.exponent)
}

// optional int32 style = 6 [deprecated = true];
inline bool Decimal::has_style() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Decimal::set_has_style() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Decimal::clear_has_style() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Decimal::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Decimal::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.style)
  return style_;
}
inline void Decimal::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.style)
}

// optional string morphosyntactic_features = 7;
inline bool Decimal::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Decimal::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Decimal::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Decimal::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Decimal::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.morphosyntactic_features)
  return morphosyntactic_features_.GetNoArena();
}
inline void Decimal::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.morphosyntactic_features)
}
#if LANG_CXX11
inline void Decimal::set_morphosyntactic_features(::std::string&& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Decimal.morphosyntactic_features)
}
#endif
inline void Decimal::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.morphosyntactic_features)
}
inline void Decimal::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.morphosyntactic_features)
}
inline ::std::string* Decimal::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.morphosyntactic_features)
  return morphosyntactic_features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Decimal::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Decimal.morphosyntactic_features)
  clear_has_morphosyntactic_features();
  return morphosyntactic_features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Decimal::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features != NULL) {
    set_has_morphosyntactic_features();
  } else {
    clear_has_morphosyntactic_features();
  }
  morphosyntactic_features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Decimal.morphosyntactic_features)
}

// optional bool preserve_order = 8;
inline bool Decimal::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Decimal::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Decimal::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Decimal::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Decimal::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.preserve_order)
  return preserve_order_;
}
inline void Decimal::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.preserve_order)
}

// optional string code_switch = 9;
inline bool Decimal::has_code_switch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Decimal::set_has_code_switch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Decimal::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Decimal::clear_code_switch() {
  code_switch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code_switch();
}
inline const ::std::string& Decimal::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.code_switch)
  return code_switch_.GetNoArena();
}
inline void Decimal::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.code_switch)
}
#if LANG_CXX11
inline void Decimal::set_code_switch(::std::string&& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Decimal.code_switch)
}
#endif
inline void Decimal::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.code_switch)
}
inline void Decimal::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.code_switch)
}
inline ::std::string* Decimal::mutable_code_switch() {
  set_has_code_switch();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.code_switch)
  return code_switch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Decimal::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Decimal.code_switch)
  clear_has_code_switch();
  return code_switch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Decimal::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch != NULL) {
    set_has_code_switch();
  } else {
    clear_has_code_switch();
  }
  code_switch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code_switch);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Decimal.code_switch)
}

// repeated string field_order = 10;
inline int Decimal::field_order_size() const {
  return field_order_.size();
}
inline void Decimal::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Decimal::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.field_order)
  return field_order_.Get(index);
}
inline ::std::string* Decimal::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.field_order)
  return field_order_.Mutable(index);
}
inline void Decimal::set_field_order(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.field_order)
  field_order_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Decimal::set_field_order(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Decimal::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.field_order)
}
inline void Decimal::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.field_order)
}
inline ::std::string* Decimal::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Decimal.field_order)
  return field_order_.Add();
}
inline void Decimal::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Decimal.field_order)
}
#if LANG_CXX11
inline void Decimal::add_field_order(::std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Decimal.field_order)
}
#endif
inline void Decimal::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Decimal.field_order)
}
inline void Decimal::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Decimal.field_order)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Decimal::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Decimal.field_order)
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Decimal::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Decimal.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Measure

// optional .speech.sparrowhawk.Decimal decimal = 1;
inline bool Measure::has_decimal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Measure::set_has_decimal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Measure::clear_has_decimal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Measure::clear_decimal() {
  if (decimal_ != NULL) decimal_->::speech::sparrowhawk::Decimal::Clear();
  clear_has_decimal();
}
inline const ::speech::sparrowhawk::Decimal& Measure::decimal() const {
  const ::speech::sparrowhawk::Decimal* p = decimal_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.decimal)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Decimal*>(
      &::speech::sparrowhawk::_Decimal_default_instance_);
}
inline ::speech::sparrowhawk::Decimal* Measure::mutable_decimal() {
  set_has_decimal();
  if (decimal_ == NULL) {
    decimal_ = new ::speech::sparrowhawk::Decimal;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.decimal)
  return decimal_;
}
inline ::speech::sparrowhawk::Decimal* Measure::release_decimal() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Measure.decimal)
  clear_has_decimal();
  ::speech::sparrowhawk::Decimal* temp = decimal_;
  decimal_ = NULL;
  return temp;
}
inline void Measure::set_allocated_decimal(::speech::sparrowhawk::Decimal* decimal) {
  delete decimal_;
  decimal_ = decimal;
  if (decimal) {
    set_has_decimal();
  } else {
    clear_has_decimal();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Measure.decimal)
}

// optional .speech.sparrowhawk.Fraction fraction = 2;
inline bool Measure::has_fraction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Measure::set_has_fraction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Measure::clear_has_fraction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Measure::clear_fraction() {
  if (fraction_ != NULL) fraction_->::speech::sparrowhawk::Fraction::Clear();
  clear_has_fraction();
}
inline const ::speech::sparrowhawk::Fraction& Measure::fraction() const {
  const ::speech::sparrowhawk::Fraction* p = fraction_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.fraction)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Fraction*>(
      &::speech::sparrowhawk::_Fraction_default_instance_);
}
inline ::speech::sparrowhawk::Fraction* Measure::mutable_fraction() {
  set_has_fraction();
  if (fraction_ == NULL) {
    fraction_ = new ::speech::sparrowhawk::Fraction;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.fraction)
  return fraction_;
}
inline ::speech::sparrowhawk::Fraction* Measure::release_fraction() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Measure.fraction)
  clear_has_fraction();
  ::speech::sparrowhawk::Fraction* temp = fraction_;
  fraction_ = NULL;
  return temp;
}
inline void Measure::set_allocated_fraction(::speech::sparrowhawk::Fraction* fraction) {
  delete fraction_;
  fraction_ = fraction;
  if (fraction) {
    set_has_fraction();
  } else {
    clear_has_fraction();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Measure.fraction)
}

// optional .speech.sparrowhawk.Cardinal cardinal = 3;
inline bool Measure::has_cardinal() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Measure::set_has_cardinal() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Measure::clear_has_cardinal() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Measure::clear_cardinal() {
  if (cardinal_ != NULL) cardinal_->::speech::sparrowhawk::Cardinal::Clear();
  clear_has_cardinal();
}
inline const ::speech::sparrowhawk::Cardinal& Measure::cardinal() const {
  const ::speech::sparrowhawk::Cardinal* p = cardinal_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.cardinal)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Cardinal*>(
      &::speech::sparrowhawk::_Cardinal_default_instance_);
}
inline ::speech::sparrowhawk::Cardinal* Measure::mutable_cardinal() {
  set_has_cardinal();
  if (cardinal_ == NULL) {
    cardinal_ = new ::speech::sparrowhawk::Cardinal;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.cardinal)
  return cardinal_;
}
inline ::speech::sparrowhawk::Cardinal* Measure::release_cardinal() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Measure.cardinal)
  clear_has_cardinal();
  ::speech::sparrowhawk::Cardinal* temp = cardinal_;
  cardinal_ = NULL;
  return temp;
}
inline void Measure::set_allocated_cardinal(::speech::sparrowhawk::Cardinal* cardinal) {
  delete cardinal_;
  cardinal_ = cardinal;
  if (cardinal) {
    set_has_cardinal();
  } else {
    clear_has_cardinal();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Measure.cardinal)
}

// optional string units = 4;
inline bool Measure::has_units() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Measure::set_has_units() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Measure::clear_has_units() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Measure::clear_units() {
  units_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_units();
}
inline const ::std::string& Measure::units() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.units)
  return units_.GetNoArena();
}
inline void Measure::set_units(const ::std::string& value) {
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.units)
}
#if LANG_CXX11
inline void Measure::set_units(::std::string&& value) {
  set_has_units();
  units_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Measure.units)
}
#endif
inline void Measure::set_units(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Measure.units)
}
inline void Measure::set_units(const char* value, size_t size) {
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Measure.units)
}
inline ::std::string* Measure::mutable_units() {
  set_has_units();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.units)
  return units_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Measure::release_units() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Measure.units)
  clear_has_units();
  return units_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Measure::set_allocated_units(::std::string* units) {
  if (units != NULL) {
    set_has_units();
  } else {
    clear_has_units();
  }
  units_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), units);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Measure.units)
}

// optional int32 style = 5 [deprecated = true];
inline bool Measure::has_style() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Measure::set_has_style() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Measure::clear_has_style() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Measure::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Measure::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.style)
  return style_;
}
inline void Measure::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.style)
}

// optional string morphosyntactic_features = 6;
inline bool Measure::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Measure::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Measure::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Measure::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Measure::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.morphosyntactic_features)
  return morphosyntactic_features_.GetNoArena();
}
inline void Measure::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.morphosyntactic_features)
}
#if LANG_CXX11
inline void Measure::set_morphosyntactic_features(::std::string&& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Measure.morphosyntactic_features)
}
#endif
inline void Measure::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Measure.morphosyntactic_features)
}
inline void Measure::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Measure.morphosyntactic_features)
}
inline ::std::string* Measure::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.morphosyntactic_features)
  return morphosyntactic_features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Measure::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Measure.morphosyntactic_features)
  clear_has_morphosyntactic_features();
  return morphosyntactic_features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Measure::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features != NULL) {
    set_has_morphosyntactic_features();
  } else {
    clear_has_morphosyntactic_features();
  }
  morphosyntactic_features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Measure.morphosyntactic_features)
}

// optional bool preserve_order = 7;
inline bool Measure::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Measure::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Measure::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Measure::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Measure::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.preserve_order)
  return preserve_order_;
}
inline void Measure::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.preserve_order)
}

// optional string code_switch = 8;
inline bool Measure::has_code_switch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Measure::set_has_code_switch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Measure::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Measure::clear_code_switch() {
  code_switch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code_switch();
}
inline const ::std::string& Measure::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.code_switch)
  return code_switch_.GetNoArena();
}
inline void Measure::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.code_switch)
}
#if LANG_CXX11
inline void Measure::set_code_switch(::std::string&& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Measure.code_switch)
}
#endif
inline void Measure::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Measure.code_switch)
}
inline void Measure::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Measure.code_switch)
}
inline ::std::string* Measure::mutable_code_switch() {
  set_has_code_switch();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.code_switch)
  return code_switch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Measure::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Measure.code_switch)
  clear_has_code_switch();
  return code_switch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Measure::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch != NULL) {
    set_has_code_switch();
  } else {
    clear_has_code_switch();
  }
  code_switch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code_switch);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Measure.code_switch)
}

// repeated string field_order = 9;
inline int Measure::field_order_size() const {
  return field_order_.size();
}
inline void Measure::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Measure::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.field_order)
  return field_order_.Get(index);
}
inline ::std::string* Measure::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.field_order)
  return field_order_.Mutable(index);
}
inline void Measure::set_field_order(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.field_order)
  field_order_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Measure::set_field_order(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Measure::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Measure.field_order)
}
inline void Measure::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Measure.field_order)
}
inline ::std::string* Measure::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Measure.field_order)
  return field_order_.Add();
}
inline void Measure::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Measure.field_order)
}
#if LANG_CXX11
inline void Measure::add_field_order(::std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Measure.field_order)
}
#endif
inline void Measure::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Measure.field_order)
}
inline void Measure::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Measure.field_order)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Measure::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Measure.field_order)
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Measure::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Measure.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Date

// optional string weekday = 1;
inline bool Date::has_weekday() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Date::set_has_weekday() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Date::clear_has_weekday() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Date::clear_weekday() {
  weekday_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_weekday();
}
inline const ::std::string& Date::weekday() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.weekday)
  return weekday_.GetNoArena();
}
inline void Date::set_weekday(const ::std::string& value) {
  set_has_weekday();
  weekday_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.weekday)
}
#if LANG_CXX11
inline void Date::set_weekday(::std::string&& value) {
  set_has_weekday();
  weekday_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.weekday)
}
#endif
inline void Date::set_weekday(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_weekday();
  weekday_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.weekday)
}
inline void Date::set_weekday(const char* value, size_t size) {
  set_has_weekday();
  weekday_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.weekday)
}
inline ::std::string* Date::mutable_weekday() {
  set_has_weekday();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.weekday)
  return weekday_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Date::release_weekday() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.weekday)
  clear_has_weekday();
  return weekday_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Date::set_allocated_weekday(::std::string* weekday) {
  if (weekday != NULL) {
    set_has_weekday();
  } else {
    clear_has_weekday();
  }
  weekday_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), weekday);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.weekday)
}

// optional string day = 2;
inline bool Date::has_day() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Date::set_has_day() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Date::clear_has_day() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Date::clear_day() {
  day_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_day();
}
inline const ::std::string& Date::day() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.day)
  return day_.GetNoArena();
}
inline void Date::set_day(const ::std::string& value) {
  set_has_day();
  day_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.day)
}
#if LANG_CXX11
inline void Date::set_day(::std::string&& value) {
  set_has_day();
  day_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.day)
}
#endif
inline void Date::set_day(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_day();
  day_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.day)
}
inline void Date::set_day(const char* value, size_t size) {
  set_has_day();
  day_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.day)
}
inline ::std::string* Date::mutable_day() {
  set_has_day();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.day)
  return day_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Date::release_day() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.day)
  clear_has_day();
  return day_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Date::set_allocated_day(::std::string* day) {
  if (day != NULL) {
    set_has_day();
  } else {
    clear_has_day();
  }
  day_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), day);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.day)
}

// optional string month = 3;
inline bool Date::has_month() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Date::set_has_month() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Date::clear_has_month() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Date::clear_month() {
  month_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_month();
}
inline const ::std::string& Date::month() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.month)
  return month_.GetNoArena();
}
inline void Date::set_month(const ::std::string& value) {
  set_has_month();
  month_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.month)
}
#if LANG_CXX11
inline void Date::set_month(::std::string&& value) {
  set_has_month();
  month_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.month)
}
#endif
inline void Date::set_month(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_month();
  month_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.month)
}
inline void Date::set_month(const char* value, size_t size) {
  set_has_month();
  month_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.month)
}
inline ::std::string* Date::mutable_month() {
  set_has_month();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.month)
  return month_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Date::release_month() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.month)
  clear_has_month();
  return month_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Date::set_allocated_month(::std::string* month) {
  if (month != NULL) {
    set_has_month();
  } else {
    clear_has_month();
  }
  month_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), month);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.month)
}

// optional string year = 4;
inline bool Date::has_year() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Date::set_has_year() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Date::clear_has_year() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Date::clear_year() {
  year_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_year();
}
inline const ::std::string& Date::year() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.year)
  return year_.GetNoArena();
}
inline void Date::set_year(const ::std::string& value) {
  set_has_year();
  year_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.year)
}
#if LANG_CXX11
inline void Date::set_year(::std::string&& value) {
  set_has_year();
  year_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.year)
}
#endif
inline void Date::set_year(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_year();
  year_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.year)
}
inline void Date::set_year(const char* value, size_t size) {
  set_has_year();
  year_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.year)
}
inline ::std::string* Date::mutable_year() {
  set_has_year();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.year)
  return year_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Date::release_year() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.year)
  clear_has_year();
  return year_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Date::set_allocated_year(::std::string* year) {
  if (year != NULL) {
    set_has_year();
  } else {
    clear_has_year();
  }
  year_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), year);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.year)
}

// optional int32 style = 5 [deprecated = true];
inline bool Date::has_style() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Date::set_has_style() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Date::clear_has_style() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Date::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Date::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.style)
  return style_;
}
inline void Date::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.style)
}

// optional string text = 6 [deprecated = true];
inline bool Date::has_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Date::set_has_text() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Date::clear_has_text() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Date::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Date::text() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.text)
  return text_.GetNoArena();
}
inline void Date::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.text)
}
#if LANG_CXX11
inline void Date::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.text)
}
#endif
inline void Date::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.text)
}
inline void Date::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.text)
}
inline ::std::string* Date::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Date::release_text() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Date::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.text)
}

// optional bool short_year = 7 [deprecated = true];
inline bool Date::has_short_year() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Date::set_has_short_year() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Date::clear_has_short_year() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Date::clear_short_year() {
  short_year_ = false;
  clear_has_short_year();
}
inline bool Date::short_year() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.short_year)
  return short_year_;
}
inline void Date::set_short_year(bool value) {
  set_has_short_year();
  short_year_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.short_year)
}

// optional string era = 8;
inline bool Date::has_era() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Date::set_has_era() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Date::clear_has_era() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Date::clear_era() {
  era_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_era();
}
inline const ::std::string& Date::era() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.era)
  return era_.GetNoArena();
}
inline void Date::set_era(const ::std::string& value) {
  set_has_era();
  era_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.era)
}
#if LANG_CXX11
inline void Date::set_era(::std::string&& value) {
  set_has_era();
  era_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.era)
}
#endif
inline void Date::set_era(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_era();
  era_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.era)
}
inline void Date::set_era(const char* value, size_t size) {
  set_has_era();
  era_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.era)
}
inline ::std::string* Date::mutable_era() {
  set_has_era();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.era)
  return era_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Date::release_era() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.era)
  clear_has_era();
  return era_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Date::set_allocated_era(::std::string* era) {
  if (era != NULL) {
    set_has_era();
  } else {
    clear_has_era();
  }
  era_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), era);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.era)
}

// optional string morphosyntactic_features = 9;
inline bool Date::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Date::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Date::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Date::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Date::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.morphosyntactic_features)
  return morphosyntactic_features_.GetNoArena();
}
inline void Date::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.morphosyntactic_features)
}
#if LANG_CXX11
inline void Date::set_morphosyntactic_features(::std::string&& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.morphosyntactic_features)
}
#endif
inline void Date::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.morphosyntactic_features)
}
inline void Date::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.morphosyntactic_features)
}
inline ::std::string* Date::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.morphosyntactic_features)
  return morphosyntactic_features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Date::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.morphosyntactic_features)
  clear_has_morphosyntactic_features();
  return morphosyntactic_features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Date::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features != NULL) {
    set_has_morphosyntactic_features();
  } else {
    clear_has_morphosyntactic_features();
  }
  morphosyntactic_features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.morphosyntactic_features)
}

// optional bool preserve_order = 10;
inline bool Date::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Date::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Date::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Date::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Date::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.preserve_order)
  return preserve_order_;
}
inline void Date::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.preserve_order)
}

// optional string code_switch = 11;
inline bool Date::has_code_switch() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Date::set_has_code_switch() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Date::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Date::clear_code_switch() {
  code_switch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code_switch();
}
inline const ::std::string& Date::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.code_switch)
  return code_switch_.GetNoArena();
}
inline void Date::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.code_switch)
}
#if LANG_CXX11
inline void Date::set_code_switch(::std::string&& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.code_switch)
}
#endif
inline void Date::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.code_switch)
}
inline void Date::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.code_switch)
}
inline ::std::string* Date::mutable_code_switch() {
  set_has_code_switch();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.code_switch)
  return code_switch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Date::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.code_switch)
  clear_has_code_switch();
  return code_switch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Date::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch != NULL) {
    set_has_code_switch();
  } else {
    clear_has_code_switch();
  }
  code_switch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code_switch);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.code_switch)
}

// repeated string field_order = 12;
inline int Date::field_order_size() const {
  return field_order_.size();
}
inline void Date::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Date::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.field_order)
  return field_order_.Get(index);
}
inline ::std::string* Date::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.field_order)
  return field_order_.Mutable(index);
}
inline void Date::set_field_order(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.field_order)
  field_order_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Date::set_field_order(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Date::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.field_order)
}
inline void Date::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.field_order)
}
inline ::std::string* Date::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Date.field_order)
  return field_order_.Add();
}
inline void Date::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Date.field_order)
}
#if LANG_CXX11
inline void Date::add_field_order(::std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Date.field_order)
}
#endif
inline void Date::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Date.field_order)
}
inline void Date::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Date.field_order)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Date::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Date.field_order)
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Date::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Date.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Money

// required .speech.sparrowhawk.Decimal amount = 1;
inline bool Money::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Money::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Money::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Money::clear_amount() {
  if (amount_ != NULL) amount_->::speech::sparrowhawk::Decimal::Clear();
  clear_has_amount();
}
inline const ::speech::sparrowhawk::Decimal& Money::amount() const {
  const ::speech::sparrowhawk::Decimal* p = amount_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.amount)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Decimal*>(
      &::speech::sparrowhawk::_Decimal_default_instance_);
}
inline ::speech::sparrowhawk::Decimal* Money::mutable_amount() {
  set_has_amount();
  if (amount_ == NULL) {
    amount_ = new ::speech::sparrowhawk::Decimal;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Money.amount)
  return amount_;
}
inline ::speech::sparrowhawk::Decimal* Money::release_amount() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Money.amount)
  clear_has_amount();
  ::speech::sparrowhawk::Decimal* temp = amount_;
  amount_ = NULL;
  return temp;
}
inline void Money::set_allocated_amount(::speech::sparrowhawk::Decimal* amount) {
  delete amount_;
  amount_ = amount;
  if (amount) {
    set_has_amount();
  } else {
    clear_has_amount();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Money.amount)
}

// optional int64 quantity = 2;
inline bool Money::has_quantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Money::set_has_quantity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Money::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Money::clear_quantity() {
  quantity_ = GOOGLE_LONGLONG(0);
  clear_has_quantity();
}
inline ::google::protobuf::int64 Money::quantity() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.quantity)
  return quantity_;
}
inline void Money::set_quantity(::google::protobuf::int64 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.quantity)
}

// required string currency = 3;
inline bool Money::has_currency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Money::set_has_currency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Money::clear_has_currency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Money::clear_currency() {
  currency_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_currency();
}
inline const ::std::string& Money::currency() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.currency)
  return currency_.GetNoArena();
}
inline void Money::set_currency(const ::std::string& value) {
  set_has_currency();
  currency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.currency)
}
#if LANG_CXX11
inline void Money::set_currency(::std::string&& value) {
  set_has_currency();
  currency_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Money.currency)
}
#endif
inline void Money::set_currency(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_currency();
  currency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Money.currency)
}
inline void Money::set_currency(const char* value, size_t size) {
  set_has_currency();
  currency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Money.currency)
}
inline ::std::string* Money::mutable_currency() {
  set_has_currency();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Money.currency)
  return currency_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Money::release_currency() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Money.currency)
  clear_has_currency();
  return currency_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Money::set_allocated_currency(::std::string* currency) {
  if (currency != NULL) {
    set_has_currency();
  } else {
    clear_has_currency();
  }
  currency_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), currency);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Money.currency)
}

// optional int32 style = 4 [deprecated = true];
inline bool Money::has_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Money::set_has_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Money::clear_has_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Money::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Money::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.style)
  return style_;
}
inline void Money::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.style)
}

// optional string morphosyntactic_features = 5;
inline bool Money::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Money::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Money::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Money::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Money::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.morphosyntactic_features)
  return morphosyntactic_features_.GetNoArena();
}
inline void Money::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.morphosyntactic_features)
}
#if LANG_CXX11
inline void Money::set_morphosyntactic_features(::std::string&& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Money.morphosyntactic_features)
}
#endif
inline void Money::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Money.morphosyntactic_features)
}
inline void Money::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Money.morphosyntactic_features)
}
inline ::std::string* Money::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Money.morphosyntactic_features)
  return morphosyntactic_features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Money::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Money.morphosyntactic_features)
  clear_has_morphosyntactic_features();
  return morphosyntactic_features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Money::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features != NULL) {
    set_has_morphosyntactic_features();
  } else {
    clear_has_morphosyntactic_features();
  }
  morphosyntactic_features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Money.morphosyntactic_features)
}

// optional bool preserve_order = 6;
inline bool Money::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Money::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Money::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Money::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Money::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.preserve_order)
  return preserve_order_;
}
inline void Money::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.preserve_order)
}

// optional string code_switch = 7;
inline bool Money::has_code_switch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Money::set_has_code_switch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Money::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Money::clear_code_switch() {
  code_switch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code_switch();
}
inline const ::std::string& Money::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.code_switch)
  return code_switch_.GetNoArena();
}
inline void Money::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.code_switch)
}
#if LANG_CXX11
inline void Money::set_code_switch(::std::string&& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Money.code_switch)
}
#endif
inline void Money::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Money.code_switch)
}
inline void Money::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Money.code_switch)
}
inline ::std::string* Money::mutable_code_switch() {
  set_has_code_switch();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Money.code_switch)
  return code_switch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Money::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Money.code_switch)
  clear_has_code_switch();
  return code_switch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Money::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch != NULL) {
    set_has_code_switch();
  } else {
    clear_has_code_switch();
  }
  code_switch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code_switch);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Money.code_switch)
}

// repeated string field_order = 8;
inline int Money::field_order_size() const {
  return field_order_.size();
}
inline void Money::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Money::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.field_order)
  return field_order_.Get(index);
}
inline ::std::string* Money::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Money.field_order)
  return field_order_.Mutable(index);
}
inline void Money::set_field_order(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.field_order)
  field_order_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Money::set_field_order(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Money::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Money.field_order)
}
inline void Money::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Money.field_order)
}
inline ::std::string* Money::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Money.field_order)
  return field_order_.Add();
}
inline void Money::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Money.field_order)
}
#if LANG_CXX11
inline void Money::add_field_order(::std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Money.field_order)
}
#endif
inline void Money::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Money.field_order)
}
inline void Money::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Money.field_order)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Money::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Money.field_order)
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Money::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Money.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Telephone

// optional string country_code = 1;
inline bool Telephone::has_country_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telephone::set_has_country_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Telephone::clear_has_country_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Telephone::clear_country_code() {
  country_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_country_code();
}
inline const ::std::string& Telephone::country_code() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.country_code)
  return country_code_.GetNoArena();
}
inline void Telephone::set_country_code(const ::std::string& value) {
  set_has_country_code();
  country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.country_code)
}
#if LANG_CXX11
inline void Telephone::set_country_code(::std::string&& value) {
  set_has_country_code();
  country_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Telephone.country_code)
}
#endif
inline void Telephone::set_country_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_country_code();
  country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Telephone.country_code)
}
inline void Telephone::set_country_code(const char* value, size_t size) {
  set_has_country_code();
  country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Telephone.country_code)
}
inline ::std::string* Telephone::mutable_country_code() {
  set_has_country_code();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Telephone.country_code)
  return country_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Telephone::release_country_code() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Telephone.country_code)
  clear_has_country_code();
  return country_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Telephone::set_allocated_country_code(::std::string* country_code) {
  if (country_code != NULL) {
    set_has_country_code();
  } else {
    clear_has_country_code();
  }
  country_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), country_code);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Telephone.country_code)
}

// repeated string number_part = 2;
inline int Telephone::number_part_size() const {
  return number_part_.size();
}
inline void Telephone::clear_number_part() {
  number_part_.Clear();
}
inline const ::std::string& Telephone::number_part(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.number_part)
  return number_part_.Get(index);
}
inline ::std::string* Telephone::mutable_number_part(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Telephone.number_part)
  return number_part_.Mutable(index);
}
inline void Telephone::set_number_part(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.number_part)
  number_part_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Telephone::set_number_part(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.number_part)
  number_part_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Telephone::set_number_part(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  number_part_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Telephone.number_part)
}
inline void Telephone::set_number_part(int index, const char* value, size_t size) {
  number_part_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Telephone.number_part)
}
inline ::std::string* Telephone::add_number_part() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Telephone.number_part)
  return number_part_.Add();
}
inline void Telephone::add_number_part(const ::std::string& value) {
  number_part_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Telephone.number_part)
}
#if LANG_CXX11
inline void Telephone::add_number_part(::std::string&& value) {
  number_part_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Telephone.number_part)
}
#endif
inline void Telephone::add_number_part(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  number_part_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Telephone.number_part)
}
inline void Telephone::add_number_part(const char* value, size_t size) {
  number_part_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Telephone.number_part)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Telephone::number_part() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Telephone.number_part)
  return number_part_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Telephone::mutable_number_part() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Telephone.number_part)
  return &number_part_;
}

// optional string extension = 3;
inline bool Telephone::has_extension() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telephone::set_has_extension() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Telephone::clear_has_extension() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Telephone::clear_extension() {
  extension_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extension();
}
inline const ::std::string& Telephone::extension() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.extension)
  return extension_.GetNoArena();
}
inline void Telephone::set_extension(const ::std::string& value) {
  set_has_extension();
  extension_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.extension)
}
#if LANG_CXX11
inline void Telephone::set_extension(::std::string&& value) {
  set_has_extension();
  extension_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Telephone.extension)
}
#endif
inline void Telephone::set_extension(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_extension();
  extension_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Telephone.extension)
}
inline void Telephone::set_extension(const char* value, size_t size) {
  set_has_extension();
  extension_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Telephone.extension)
}
inline ::std::string* Telephone::mutable_extension() {
  set_has_extension();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Telephone.extension)
  return extension_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Telephone::release_extension() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Telephone.extension)
  clear_has_extension();
  return extension_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Telephone::set_allocated_extension(::std::string* extension) {
  if (extension != NULL) {
    set_has_extension();
  } else {
    clear_has_extension();
  }
  extension_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extension);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Telephone.extension)
}

// optional int32 style = 4 [deprecated = true];
inline bool Telephone::has_style() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Telephone::set_has_style() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Telephone::clear_has_style() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Telephone::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Telephone::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.style)
  return style_;
}
inline void Telephone::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.style)
}

// optional string morphosyntactic_features = 5;
inline bool Telephone::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telephone::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Telephone::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Telephone::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Telephone::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.morphosyntactic_features)
  return morphosyntactic_features_.GetNoArena();
}
inline void Telephone::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.morphosyntactic_features)
}
#if LANG_CXX11
inline void Telephone::set_morphosyntactic_features(::std::string&& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Telephone.morphosyntactic_features)
}
#endif
inline void Telephone::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Telephone.morphosyntactic_features)
}
inline void Telephone::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Telephone.morphosyntactic_features)
}
inline ::std::string* Telephone::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Telephone.morphosyntactic_features)
  return morphosyntactic_features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Telephone::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Telephone.morphosyntactic_features)
  clear_has_morphosyntactic_features();
  return morphosyntactic_features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Telephone::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features != NULL) {
    set_has_morphosyntactic_features();
  } else {
    clear_has_morphosyntactic_features();
  }
  morphosyntactic_features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Telephone.morphosyntactic_features)
}

// optional bool preserve_order = 6;
inline bool Telephone::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Telephone::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Telephone::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Telephone::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Telephone::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.preserve_order)
  return preserve_order_;
}
inline void Telephone::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.preserve_order)
}

// optional string code_switch = 7;
inline bool Telephone::has_code_switch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telephone::set_has_code_switch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Telephone::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Telephone::clear_code_switch() {
  code_switch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code_switch();
}
inline const ::std::string& Telephone::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.code_switch)
  return code_switch_.GetNoArena();
}
inline void Telephone::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.code_switch)
}
#if LANG_CXX11
inline void Telephone::set_code_switch(::std::string&& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Telephone.code_switch)
}
#endif
inline void Telephone::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Telephone.code_switch)
}
inline void Telephone::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Telephone.code_switch)
}
inline ::std::string* Telephone::mutable_code_switch() {
  set_has_code_switch();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Telephone.code_switch)
  return code_switch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Telephone::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Telephone.code_switch)
  clear_has_code_switch();
  return code_switch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Telephone::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch != NULL) {
    set_has_code_switch();
  } else {
    clear_has_code_switch();
  }
  code_switch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code_switch);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Telephone.code_switch)
}

// repeated string field_order = 8;
inline int Telephone::field_order_size() const {
  return field_order_.size();
}
inline void Telephone::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Telephone::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.field_order)
  return field_order_.Get(index);
}
inline ::std::string* Telephone::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Telephone.field_order)
  return field_order_.Mutable(index);
}
inline void Telephone::set_field_order(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.field_order)
  field_order_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Telephone::set_field_order(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Telephone::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Telephone.field_order)
}
inline void Telephone::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Telephone.field_order)
}
inline ::std::string* Telephone::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Telephone.field_order)
  return field_order_.Add();
}
inline void Telephone::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Telephone.field_order)
}
#if LANG_CXX11
inline void Telephone::add_field_order(::std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Telephone.field_order)
}
#endif
inline void Telephone::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Telephone.field_order)
}
inline void Telephone::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Telephone.field_order)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Telephone::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Telephone.field_order)
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Telephone::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Telephone.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Electronic

// optional string protocol = 1;
inline bool Electronic::has_protocol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Electronic::set_has_protocol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Electronic::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Electronic::clear_protocol() {
  protocol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol();
}
inline const ::std::string& Electronic::protocol() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.protocol)
  return protocol_.GetNoArena();
}
inline void Electronic::set_protocol(const ::std::string& value) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.protocol)
}
#if LANG_CXX11
inline void Electronic::set_protocol(::std::string&& value) {
  set_has_protocol();
  protocol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.protocol)
}
#endif
inline void Electronic::set_protocol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.protocol)
}
inline void Electronic::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.protocol)
}
inline ::std::string* Electronic::mutable_protocol() {
  set_has_protocol();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.protocol)
  return protocol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Electronic::release_protocol() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.protocol)
  clear_has_protocol();
  return protocol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Electronic::set_allocated_protocol(::std::string* protocol) {
  if (protocol != NULL) {
    set_has_protocol();
  } else {
    clear_has_protocol();
  }
  protocol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.protocol)
}

// optional string username = 2;
inline bool Electronic::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Electronic::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Electronic::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Electronic::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& Electronic::username() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.username)
  return username_.GetNoArena();
}
inline void Electronic::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.username)
}
#if LANG_CXX11
inline void Electronic::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.username)
}
#endif
inline void Electronic::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.username)
}
inline void Electronic::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.username)
}
inline ::std::string* Electronic::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Electronic::release_username() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.username)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Electronic::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.username)
}

// optional string password = 3;
inline bool Electronic::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Electronic::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Electronic::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Electronic::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& Electronic::password() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.password)
  return password_.GetNoArena();
}
inline void Electronic::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.password)
}
#if LANG_CXX11
inline void Electronic::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.password)
}
#endif
inline void Electronic::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.password)
}
inline void Electronic::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.password)
}
inline ::std::string* Electronic::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Electronic::release_password() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Electronic::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.password)
}

// optional string domain = 4;
inline bool Electronic::has_domain() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Electronic::set_has_domain() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Electronic::clear_has_domain() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Electronic::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_domain();
}
inline const ::std::string& Electronic::domain() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.domain)
  return domain_.GetNoArena();
}
inline void Electronic::set_domain(const ::std::string& value) {
  set_has_domain();
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.domain)
}
#if LANG_CXX11
inline void Electronic::set_domain(::std::string&& value) {
  set_has_domain();
  domain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.domain)
}
#endif
inline void Electronic::set_domain(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_domain();
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.domain)
}
inline void Electronic::set_domain(const char* value, size_t size) {
  set_has_domain();
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.domain)
}
inline ::std::string* Electronic::mutable_domain() {
  set_has_domain();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Electronic::release_domain() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.domain)
  clear_has_domain();
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Electronic::set_allocated_domain(::std::string* domain) {
  if (domain != NULL) {
    set_has_domain();
  } else {
    clear_has_domain();
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.domain)
}

// optional int32 port = 5;
inline bool Electronic::has_port() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Electronic::set_has_port() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Electronic::clear_has_port() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Electronic::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Electronic::port() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.port)
  return port_;
}
inline void Electronic::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.port)
}

// optional string path = 6;
inline bool Electronic::has_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Electronic::set_has_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Electronic::clear_has_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Electronic::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& Electronic::path() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.path)
  return path_.GetNoArena();
}
inline void Electronic::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.path)
}
#if LANG_CXX11
inline void Electronic::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.path)
}
#endif
inline void Electronic::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.path)
}
inline void Electronic::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.path)
}
inline ::std::string* Electronic::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Electronic::release_path() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Electronic::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.path)
}

// optional string query_string = 7;
inline bool Electronic::has_query_string() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Electronic::set_has_query_string() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Electronic::clear_has_query_string() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Electronic::clear_query_string() {
  query_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_query_string();
}
inline const ::std::string& Electronic::query_string() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.query_string)
  return query_string_.GetNoArena();
}
inline void Electronic::set_query_string(const ::std::string& value) {
  set_has_query_string();
  query_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.query_string)
}
#if LANG_CXX11
inline void Electronic::set_query_string(::std::string&& value) {
  set_has_query_string();
  query_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.query_string)
}
#endif
inline void Electronic::set_query_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_query_string();
  query_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.query_string)
}
inline void Electronic::set_query_string(const char* value, size_t size) {
  set_has_query_string();
  query_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.query_string)
}
inline ::std::string* Electronic::mutable_query_string() {
  set_has_query_string();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.query_string)
  return query_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Electronic::release_query_string() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.query_string)
  clear_has_query_string();
  return query_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Electronic::set_allocated_query_string(::std::string* query_string) {
  if (query_string != NULL) {
    set_has_query_string();
  } else {
    clear_has_query_string();
  }
  query_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query_string);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.query_string)
}

// optional string fragment_id = 8;
inline bool Electronic::has_fragment_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Electronic::set_has_fragment_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Electronic::clear_has_fragment_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Electronic::clear_fragment_id() {
  fragment_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fragment_id();
}
inline const ::std::string& Electronic::fragment_id() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.fragment_id)
  return fragment_id_.GetNoArena();
}
inline void Electronic::set_fragment_id(const ::std::string& value) {
  set_has_fragment_id();
  fragment_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.fragment_id)
}
#if LANG_CXX11
inline void Electronic::set_fragment_id(::std::string&& value) {
  set_has_fragment_id();
  fragment_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.fragment_id)
}
#endif
inline void Electronic::set_fragment_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fragment_id();
  fragment_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.fragment_id)
}
inline void Electronic::set_fragment_id(const char* value, size_t size) {
  set_has_fragment_id();
  fragment_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.fragment_id)
}
inline ::std::string* Electronic::mutable_fragment_id() {
  set_has_fragment_id();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.fragment_id)
  return fragment_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Electronic::release_fragment_id() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.fragment_id)
  clear_has_fragment_id();
  return fragment_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Electronic::set_allocated_fragment_id(::std::string* fragment_id) {
  if (fragment_id != NULL) {
    set_has_fragment_id();
  } else {
    clear_has_fragment_id();
  }
  fragment_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fragment_id);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.fragment_id)
}

// optional string morphosyntactic_features = 9;
inline bool Electronic::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Electronic::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Electronic::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Electronic::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Electronic::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.morphosyntactic_features)
  return morphosyntactic_features_.GetNoArena();
}
inline void Electronic::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.morphosyntactic_features)
}
#if LANG_CXX11
inline void Electronic::set_morphosyntactic_features(::std::string&& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.morphosyntactic_features)
}
#endif
inline void Electronic::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.morphosyntactic_features)
}
inline void Electronic::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.morphosyntactic_features)
}
inline ::std::string* Electronic::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.morphosyntactic_features)
  return morphosyntactic_features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Electronic::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.morphosyntactic_features)
  clear_has_morphosyntactic_features();
  return morphosyntactic_features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Electronic::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features != NULL) {
    set_has_morphosyntactic_features();
  } else {
    clear_has_morphosyntactic_features();
  }
  morphosyntactic_features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.morphosyntactic_features)
}

// optional bool preserve_order = 10;
inline bool Electronic::has_preserve_order() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Electronic::set_has_preserve_order() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Electronic::clear_has_preserve_order() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Electronic::clear_preserve_order() {
  preserve_order_ = false;
  clear_has_preserve_order();
}
inline bool Electronic::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.preserve_order)
  return preserve_order_;
}
inline void Electronic::set_preserve_order(bool value) {
  set_has_preserve_order();
  preserve_order_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.preserve_order)
}

// optional string code_switch = 11;
inline bool Electronic::has_code_switch() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Electronic::set_has_code_switch() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Electronic::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Electronic::clear_code_switch() {
  code_switch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code_switch();
}
inline const ::std::string& Electronic::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.code_switch)
  return code_switch_.GetNoArena();
}
inline void Electronic::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.code_switch)
}
#if LANG_CXX11
inline void Electronic::set_code_switch(::std::string&& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.code_switch)
}
#endif
inline void Electronic::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.code_switch)
}
inline void Electronic::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.code_switch)
}
inline ::std::string* Electronic::mutable_code_switch() {
  set_has_code_switch();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.code_switch)
  return code_switch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Electronic::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.code_switch)
  clear_has_code_switch();
  return code_switch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Electronic::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch != NULL) {
    set_has_code_switch();
  } else {
    clear_has_code_switch();
  }
  code_switch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code_switch);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.code_switch)
}

// repeated string field_order = 12;
inline int Electronic::field_order_size() const {
  return field_order_.size();
}
inline void Electronic::clear_field_order() {
  field_order_.Clear();
}
inline const ::std::string& Electronic::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.field_order)
  return field_order_.Get(index);
}
inline ::std::string* Electronic::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.field_order)
  return field_order_.Mutable(index);
}
inline void Electronic::set_field_order(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.field_order)
  field_order_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Electronic::set_field_order(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Electronic::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.field_order)
}
inline void Electronic::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.field_order)
}
inline ::std::string* Electronic::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Electronic.field_order)
  return field_order_.Add();
}
inline void Electronic::add_field_order(const ::std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Electronic.field_order)
}
#if LANG_CXX11
inline void Electronic::add_field_order(::std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Electronic.field_order)
}
#endif
inline void Electronic::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Electronic.field_order)
}
inline void Electronic::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Electronic.field_order)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Electronic::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Electronic.field_order)
  return field_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Electronic::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Electronic.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Connector

// optional string type = 1;
inline bool Connector::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Connector::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Connector::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Connector::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& Connector::type() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Connector.type)
  return type_.GetNoArena();
}
inline void Connector::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Connector.type)
}
#if LANG_CXX11
inline void Connector::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Connector.type)
}
#endif
inline void Connector::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Connector.type)
}
inline void Connector::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Connector.type)
}
inline ::std::string* Connector::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Connector.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connector::release_type() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Connector.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connector::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Connector.type)
}

// optional string morphosyntactic_features = 2;
inline bool Connector::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Connector::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Connector::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Connector::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Connector::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Connector.morphosyntactic_features)
  return morphosyntactic_features_.GetNoArena();
}
inline void Connector::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Connector.morphosyntactic_features)
}
#if LANG_CXX11
inline void Connector::set_morphosyntactic_features(::std::string&& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Connector.morphosyntactic_features)
}
#endif
inline void Connector::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Connector.morphosyntactic_features)
}
inline void Connector::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Connector.morphosyntactic_features)
}
inline ::std::string* Connector::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Connector.morphosyntactic_features)
  return morphosyntactic_features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connector::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Connector.morphosyntactic_features)
  clear_has_morphosyntactic_features();
  return morphosyntactic_features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connector::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features != NULL) {
    set_has_morphosyntactic_features();
  } else {
    clear_has_morphosyntactic_features();
  }
  morphosyntactic_features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Connector.morphosyntactic_features)
}

// optional string code_switch = 3;
inline bool Connector::has_code_switch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Connector::set_has_code_switch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Connector::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Connector::clear_code_switch() {
  code_switch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code_switch();
}
inline const ::std::string& Connector::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Connector.code_switch)
  return code_switch_.GetNoArena();
}
inline void Connector::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Connector.code_switch)
}
#if LANG_CXX11
inline void Connector::set_code_switch(::std::string&& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Connector.code_switch)
}
#endif
inline void Connector::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Connector.code_switch)
}
inline void Connector::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Connector.code_switch)
}
inline ::std::string* Connector::mutable_code_switch() {
  set_has_code_switch();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Connector.code_switch)
  return code_switch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connector::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Connector.code_switch)
  clear_has_code_switch();
  return code_switch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connector::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch != NULL) {
    set_has_code_switch();
  } else {
    clear_has_code_switch();
  }
  code_switch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code_switch);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Connector.code_switch)
}

// -------------------------------------------------------------------

// Abbreviation

// required string text = 1;
inline bool Abbreviation::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Abbreviation::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Abbreviation::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Abbreviation::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Abbreviation::text() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Abbreviation.text)
  return text_.GetNoArena();
}
inline void Abbreviation::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Abbreviation.text)
}
#if LANG_CXX11
inline void Abbreviation::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Abbreviation.text)
}
#endif
inline void Abbreviation::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Abbreviation.text)
}
inline void Abbreviation::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Abbreviation.text)
}
inline ::std::string* Abbreviation::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Abbreviation.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Abbreviation::release_text() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Abbreviation.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Abbreviation::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Abbreviation.text)
}

// optional string morphosyntactic_features = 2;
inline bool Abbreviation::has_morphosyntactic_features() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Abbreviation::set_has_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Abbreviation::clear_has_morphosyntactic_features() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Abbreviation::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_morphosyntactic_features();
}
inline const ::std::string& Abbreviation::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
  return morphosyntactic_features_.GetNoArena();
}
inline void Abbreviation::set_morphosyntactic_features(const ::std::string& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
}
#if LANG_CXX11
inline void Abbreviation::set_morphosyntactic_features(::std::string&& value) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
}
#endif
inline void Abbreviation::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
}
inline void Abbreviation::set_morphosyntactic_features(const char* value, size_t size) {
  set_has_morphosyntactic_features();
  morphosyntactic_features_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
}
inline ::std::string* Abbreviation::mutable_morphosyntactic_features() {
  set_has_morphosyntactic_features();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
  return morphosyntactic_features_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Abbreviation::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
  clear_has_morphosyntactic_features();
  return morphosyntactic_features_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Abbreviation::set_allocated_morphosyntactic_features(::std::string* morphosyntactic_features) {
  if (morphosyntactic_features != NULL) {
    set_has_morphosyntactic_features();
  } else {
    clear_has_morphosyntactic_features();
  }
  morphosyntactic_features_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
}

// optional string code_switch = 3;
inline bool Abbreviation::has_code_switch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Abbreviation::set_has_code_switch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Abbreviation::clear_has_code_switch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Abbreviation::clear_code_switch() {
  code_switch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code_switch();
}
inline const ::std::string& Abbreviation::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Abbreviation.code_switch)
  return code_switch_.GetNoArena();
}
inline void Abbreviation::set_code_switch(const ::std::string& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Abbreviation.code_switch)
}
#if LANG_CXX11
inline void Abbreviation::set_code_switch(::std::string&& value) {
  set_has_code_switch();
  code_switch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Abbreviation.code_switch)
}
#endif
inline void Abbreviation::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Abbreviation.code_switch)
}
inline void Abbreviation::set_code_switch(const char* value, size_t size) {
  set_has_code_switch();
  code_switch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Abbreviation.code_switch)
}
inline ::std::string* Abbreviation::mutable_code_switch() {
  set_has_code_switch();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Abbreviation.code_switch)
  return code_switch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Abbreviation::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Abbreviation.code_switch)
  clear_has_code_switch();
  return code_switch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Abbreviation::set_allocated_code_switch(::std::string* code_switch) {
  if (code_switch != NULL) {
    set_has_code_switch();
  } else {
    clear_has_code_switch();
  }
  code_switch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code_switch);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Abbreviation.code_switch)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sparrowhawk
}  // namespace speech

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_semiotic_5fclasses_2eproto__INCLUDED
