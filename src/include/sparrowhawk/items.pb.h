// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: items.proto

#ifndef PROTOBUF_items_2eproto__INCLUDED
#define PROTOBUF_items_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "links.pb.h"
#include "semiotic_classes.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_items_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsTokenImpl();
void InitDefaultsToken();
void InitDefaultsWordImpl();
void InitDefaultsWord();
void InitDefaultsLinguisticStructureImpl();
void InitDefaultsLinguisticStructure();
void InitDefaultsUtteranceImpl();
void InitDefaultsUtterance();
inline void InitDefaults() {
  InitDefaultsToken();
  InitDefaultsWord();
  InitDefaultsLinguisticStructure();
  InitDefaultsUtterance();
}
}  // namespace protobuf_items_2eproto
namespace speech {
namespace sparrowhawk {
class LinguisticStructure;
class LinguisticStructureDefaultTypeInternal;
extern LinguisticStructureDefaultTypeInternal _LinguisticStructure_default_instance_;
class Token;
class TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
class Utterance;
class UtteranceDefaultTypeInternal;
extern UtteranceDefaultTypeInternal _Utterance_default_instance_;
class Word;
class WordDefaultTypeInternal;
extern WordDefaultTypeInternal _Word_default_instance_;
}  // namespace sparrowhawk
}  // namespace speech
namespace speech {
namespace sparrowhawk {

enum Token_Type {
  Token_Type_WORD = 1,
  Token_Type_SEMIOTIC_CLASS = 2,
  Token_Type_PUNCT = 3,
  Token_Type_WORD_NEEDS_VERBALIZATION = 4
};
bool Token_Type_IsValid(int value);
const Token_Type Token_Type_Type_MIN = Token_Type_WORD;
const Token_Type Token_Type_Type_MAX = Token_Type_WORD_NEEDS_VERBALIZATION;
const int Token_Type_Type_ARRAYSIZE = Token_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Token_Type_descriptor();
inline const ::std::string& Token_Type_Name(Token_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Token_Type_descriptor(), value);
}
inline bool Token_Type_Parse(
    const ::std::string& name, Token_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Token_Type>(
    Token_Type_descriptor(), name, value);
}
enum Token_PauseLength {
  Token_PauseLength_PAUSE_NONE = 0,
  Token_PauseLength_PAUSE_SHORT = 1,
  Token_PauseLength_PAUSE_MEDIUM = 2,
  Token_PauseLength_PAUSE_LONG = 3
};
bool Token_PauseLength_IsValid(int value);
const Token_PauseLength Token_PauseLength_PauseLength_MIN = Token_PauseLength_PAUSE_NONE;
const Token_PauseLength Token_PauseLength_PauseLength_MAX = Token_PauseLength_PAUSE_LONG;
const int Token_PauseLength_PauseLength_ARRAYSIZE = Token_PauseLength_PauseLength_MAX + 1;

const ::google::protobuf::EnumDescriptor* Token_PauseLength_descriptor();
inline const ::std::string& Token_PauseLength_Name(Token_PauseLength value) {
  return ::google::protobuf::internal::NameOfEnum(
    Token_PauseLength_descriptor(), value);
}
inline bool Token_PauseLength_Parse(
    const ::std::string& name, Token_PauseLength* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Token_PauseLength>(
    Token_PauseLength_descriptor(), name, value);
}
// ===================================================================

class Token : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Token) */ {
 public:
  Token();
  virtual ~Token();

  Token(const Token& from);

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(Token&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Token& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Token* other);
  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Token* New() const PROTOBUF_FINAL { return New(NULL); }

  Token* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Token& from);
  void MergeFrom(const Token& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Token* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Token_Type Type;
  static const Type WORD =
    Token_Type_WORD;
  static const Type SEMIOTIC_CLASS =
    Token_Type_SEMIOTIC_CLASS;
  static const Type PUNCT =
    Token_Type_PUNCT;
  static const Type WORD_NEEDS_VERBALIZATION =
    Token_Type_WORD_NEEDS_VERBALIZATION;
  static inline bool Type_IsValid(int value) {
    return Token_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Token_Type_Type_MIN;
  static const Type Type_MAX =
    Token_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Token_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Token_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Token_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Token_Type_Parse(name, value);
  }

  typedef Token_PauseLength PauseLength;
  static const PauseLength PAUSE_NONE =
    Token_PauseLength_PAUSE_NONE;
  static const PauseLength PAUSE_SHORT =
    Token_PauseLength_PAUSE_SHORT;
  static const PauseLength PAUSE_MEDIUM =
    Token_PauseLength_PAUSE_MEDIUM;
  static const PauseLength PAUSE_LONG =
    Token_PauseLength_PAUSE_LONG;
  static inline bool PauseLength_IsValid(int value) {
    return Token_PauseLength_IsValid(value);
  }
  static const PauseLength PauseLength_MIN =
    Token_PauseLength_PauseLength_MIN;
  static const PauseLength PauseLength_MAX =
    Token_PauseLength_PauseLength_MAX;
  static const int PauseLength_ARRAYSIZE =
    Token_PauseLength_PauseLength_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PauseLength_descriptor() {
    return Token_PauseLength_descriptor();
  }
  static inline const ::std::string& PauseLength_Name(PauseLength value) {
    return Token_PauseLength_Name(value);
  }
  static inline bool PauseLength_Parse(const ::std::string& name,
      PauseLength* value) {
    return Token_PauseLength_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 4;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string wordid = 6;
  bool has_wordid() const;
  void clear_wordid();
  static const int kWordidFieldNumber = 6;
  const ::std::string& wordid() const;
  void set_wordid(const ::std::string& value);
  #if LANG_CXX11
  void set_wordid(::std::string&& value);
  #endif
  void set_wordid(const char* value);
  void set_wordid(const char* value, size_t size);
  ::std::string* mutable_wordid();
  ::std::string* release_wordid();
  void set_allocated_wordid(::std::string* wordid);

  // optional string spelling = 7;
  bool has_spelling() const;
  void clear_spelling();
  static const int kSpellingFieldNumber = 7;
  const ::std::string& spelling() const;
  void set_spelling(const ::std::string& value);
  #if LANG_CXX11
  void set_spelling(::std::string&& value);
  #endif
  void set_spelling(const char* value);
  void set_spelling(const char* value, size_t size);
  ::std::string* mutable_spelling();
  ::std::string* release_spelling();
  void set_allocated_spelling(::std::string* spelling);

  // optional string spelling_with_stress = 11;
  bool has_spelling_with_stress() const;
  void clear_spelling_with_stress();
  static const int kSpellingWithStressFieldNumber = 11;
  const ::std::string& spelling_with_stress() const;
  void set_spelling_with_stress(const ::std::string& value);
  #if LANG_CXX11
  void set_spelling_with_stress(::std::string&& value);
  #endif
  void set_spelling_with_stress(const char* value);
  void set_spelling_with_stress(const char* value, size_t size);
  ::std::string* mutable_spelling_with_stress();
  ::std::string* release_spelling_with_stress();
  void set_allocated_spelling_with_stress(::std::string* spelling_with_stress);

  // optional string digit = 16;
  bool has_digit() const;
  void clear_digit();
  static const int kDigitFieldNumber = 16;
  const ::std::string& digit() const;
  void set_digit(const ::std::string& value);
  #if LANG_CXX11
  void set_digit(::std::string&& value);
  #endif
  void set_digit(const char* value);
  void set_digit(const char* value, size_t size);
  ::std::string* mutable_digit();
  ::std::string* release_digit();
  void set_allocated_digit(::std::string* digit);

  // optional string verbatim = 26;
  bool has_verbatim() const;
  void clear_verbatim();
  static const int kVerbatimFieldNumber = 26;
  const ::std::string& verbatim() const;
  void set_verbatim(const ::std::string& value);
  #if LANG_CXX11
  void set_verbatim(::std::string&& value);
  #endif
  void set_verbatim(const char* value);
  void set_verbatim(const char* value, size_t size);
  ::std::string* mutable_verbatim();
  ::std::string* release_verbatim();
  void set_allocated_verbatim(::std::string* verbatim);

  // optional string letters = 27;
  bool has_letters() const;
  void clear_letters();
  static const int kLettersFieldNumber = 27;
  const ::std::string& letters() const;
  void set_letters(const ::std::string& value);
  #if LANG_CXX11
  void set_letters(::std::string&& value);
  #endif
  void set_letters(const char* value);
  void set_letters(const char* value, size_t size);
  ::std::string* mutable_letters();
  ::std::string* release_letters();
  void set_allocated_letters(::std::string* letters);

  // optional .speech.sparrowhawk.Links links = 1;
  bool has_links() const;
  void clear_links();
  static const int kLinksFieldNumber = 1;
  const ::speech::sparrowhawk::Links& links() const;
  ::speech::sparrowhawk::Links* mutable_links();
  ::speech::sparrowhawk::Links* release_links();
  void set_allocated_links(::speech::sparrowhawk::Links* links);

  // optional .speech.sparrowhawk.Cardinal cardinal = 14;
  bool has_cardinal() const;
  void clear_cardinal();
  static const int kCardinalFieldNumber = 14;
  const ::speech::sparrowhawk::Cardinal& cardinal() const;
  ::speech::sparrowhawk::Cardinal* mutable_cardinal();
  ::speech::sparrowhawk::Cardinal* release_cardinal();
  void set_allocated_cardinal(::speech::sparrowhawk::Cardinal* cardinal);

  // optional .speech.sparrowhawk.Ordinal ordinal = 15;
  bool has_ordinal() const;
  void clear_ordinal();
  static const int kOrdinalFieldNumber = 15;
  const ::speech::sparrowhawk::Ordinal& ordinal() const;
  ::speech::sparrowhawk::Ordinal* mutable_ordinal();
  ::speech::sparrowhawk::Ordinal* release_ordinal();
  void set_allocated_ordinal(::speech::sparrowhawk::Ordinal* ordinal);

  // optional .speech.sparrowhawk.Decimal decimal = 17;
  bool has_decimal() const;
  void clear_decimal();
  static const int kDecimalFieldNumber = 17;
  const ::speech::sparrowhawk::Decimal& decimal() const;
  ::speech::sparrowhawk::Decimal* mutable_decimal();
  ::speech::sparrowhawk::Decimal* release_decimal();
  void set_allocated_decimal(::speech::sparrowhawk::Decimal* decimal);

  // optional .speech.sparrowhawk.Fraction fraction = 18;
  bool has_fraction() const;
  void clear_fraction();
  static const int kFractionFieldNumber = 18;
  const ::speech::sparrowhawk::Fraction& fraction() const;
  ::speech::sparrowhawk::Fraction* mutable_fraction();
  ::speech::sparrowhawk::Fraction* release_fraction();
  void set_allocated_fraction(::speech::sparrowhawk::Fraction* fraction);

  // optional .speech.sparrowhawk.Time time = 19;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 19;
  const ::speech::sparrowhawk::Time& time() const;
  ::speech::sparrowhawk::Time* mutable_time();
  ::speech::sparrowhawk::Time* release_time();
  void set_allocated_time(::speech::sparrowhawk::Time* time);

  // optional .speech.sparrowhawk.Measure measure = 20;
  bool has_measure() const;
  void clear_measure();
  static const int kMeasureFieldNumber = 20;
  const ::speech::sparrowhawk::Measure& measure() const;
  ::speech::sparrowhawk::Measure* mutable_measure();
  ::speech::sparrowhawk::Measure* release_measure();
  void set_allocated_measure(::speech::sparrowhawk::Measure* measure);

  // optional .speech.sparrowhawk.Decimal percent = 21;
  bool has_percent() const;
  void clear_percent();
  static const int kPercentFieldNumber = 21;
  const ::speech::sparrowhawk::Decimal& percent() const;
  ::speech::sparrowhawk::Decimal* mutable_percent();
  ::speech::sparrowhawk::Decimal* release_percent();
  void set_allocated_percent(::speech::sparrowhawk::Decimal* percent);

  // optional .speech.sparrowhawk.Date date = 22;
  bool has_date() const;
  void clear_date();
  static const int kDateFieldNumber = 22;
  const ::speech::sparrowhawk::Date& date() const;
  ::speech::sparrowhawk::Date* mutable_date();
  ::speech::sparrowhawk::Date* release_date();
  void set_allocated_date(::speech::sparrowhawk::Date* date);

  // optional .speech.sparrowhawk.Telephone telephone = 23;
  bool has_telephone() const;
  void clear_telephone();
  static const int kTelephoneFieldNumber = 23;
  const ::speech::sparrowhawk::Telephone& telephone() const;
  ::speech::sparrowhawk::Telephone* mutable_telephone();
  ::speech::sparrowhawk::Telephone* release_telephone();
  void set_allocated_telephone(::speech::sparrowhawk::Telephone* telephone);

  // optional .speech.sparrowhawk.Money money = 24;
  bool has_money() const;
  void clear_money();
  static const int kMoneyFieldNumber = 24;
  const ::speech::sparrowhawk::Money& money() const;
  ::speech::sparrowhawk::Money* mutable_money();
  ::speech::sparrowhawk::Money* release_money();
  void set_allocated_money(::speech::sparrowhawk::Money* money);

  // optional .speech.sparrowhawk.Electronic electronic = 25;
  bool has_electronic() const;
  void clear_electronic();
  static const int kElectronicFieldNumber = 25;
  const ::speech::sparrowhawk::Electronic& electronic() const;
  ::speech::sparrowhawk::Electronic* mutable_electronic();
  ::speech::sparrowhawk::Electronic* release_electronic();
  void set_allocated_electronic(::speech::sparrowhawk::Electronic* electronic);

  // optional .speech.sparrowhawk.Connector connector = 28;
  bool has_connector() const;
  void clear_connector();
  static const int kConnectorFieldNumber = 28;
  const ::speech::sparrowhawk::Connector& connector() const;
  ::speech::sparrowhawk::Connector* mutable_connector();
  ::speech::sparrowhawk::Connector* release_connector();
  void set_allocated_connector(::speech::sparrowhawk::Connector* connector);

  // optional .speech.sparrowhawk.Abbreviation abbreviation = 29;
  bool has_abbreviation() const;
  void clear_abbreviation();
  static const int kAbbreviationFieldNumber = 29;
  const ::speech::sparrowhawk::Abbreviation& abbreviation() const;
  ::speech::sparrowhawk::Abbreviation* mutable_abbreviation();
  ::speech::sparrowhawk::Abbreviation* release_abbreviation();
  void set_allocated_abbreviation(::speech::sparrowhawk::Abbreviation* abbreviation);

  // optional uint32 start_index = 2;
  bool has_start_index() const;
  void clear_start_index();
  static const int kStartIndexFieldNumber = 2;
  ::google::protobuf::uint32 start_index() const;
  void set_start_index(::google::protobuf::uint32 value);

  // optional uint32 end_index = 3;
  bool has_end_index() const;
  void clear_end_index();
  static const int kEndIndexFieldNumber = 3;
  ::google::protobuf::uint32 end_index() const;
  void set_end_index(::google::protobuf::uint32 value);

  // optional float pause_duration = 9;
  bool has_pause_duration() const;
  void clear_pause_duration();
  static const int kPauseDurationFieldNumber = 9;
  float pause_duration() const;
  void set_pause_duration(float value);

  // optional .speech.sparrowhawk.Token.PauseLength pause_length = 10 [default = PAUSE_NONE];
  bool has_pause_length() const;
  void clear_pause_length();
  static const int kPauseLengthFieldNumber = 10;
  ::speech::sparrowhawk::Token_PauseLength pause_length() const;
  void set_pause_length(::speech::sparrowhawk::Token_PauseLength value);

  // optional bool phrase_break = 8;
  bool has_phrase_break() const;
  void clear_phrase_break();
  static const int kPhraseBreakFieldNumber = 8;
  bool phrase_break() const;
  void set_phrase_break(bool value);

  // optional bool skip = 12;
  bool has_skip() const;
  void clear_skip();
  static const int kSkipFieldNumber = 12;
  bool skip() const;
  void set_skip(bool value);

  // optional bool next_space = 13;
  bool has_next_space() const;
  void clear_next_space();
  static const int kNextSpaceFieldNumber = 13;
  bool next_space() const;
  void set_next_space(bool value);

  // optional int32 first_daughter = 30;
  bool has_first_daughter() const;
  void clear_first_daughter();
  static const int kFirstDaughterFieldNumber = 30;
  ::google::protobuf::int32 first_daughter() const;
  void set_first_daughter(::google::protobuf::int32 value);

  // optional int32 last_daughter = 31;
  bool has_last_daughter() const;
  void clear_last_daughter();
  static const int kLastDaughterFieldNumber = 31;
  ::google::protobuf::int32 last_daughter() const;
  void set_last_daughter(::google::protobuf::int32 value);

  // optional .speech.sparrowhawk.Token.Type type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::speech::sparrowhawk::Token_Type type() const;
  void set_type(::speech::sparrowhawk::Token_Type value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Token)
  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Token)
 private:
  void set_has_links();
  void clear_has_links();
  void set_has_start_index();
  void clear_has_start_index();
  void set_has_end_index();
  void clear_has_end_index();
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_wordid();
  void clear_has_wordid();
  void set_has_spelling();
  void clear_has_spelling();
  void set_has_phrase_break();
  void clear_has_phrase_break();
  void set_has_pause_duration();
  void clear_has_pause_duration();
  void set_has_pause_length();
  void clear_has_pause_length();
  void set_has_spelling_with_stress();
  void clear_has_spelling_with_stress();
  void set_has_skip();
  void clear_has_skip();
  void set_has_next_space();
  void clear_has_next_space();
  void set_has_cardinal();
  void clear_has_cardinal();
  void set_has_ordinal();
  void clear_has_ordinal();
  void set_has_digit();
  void clear_has_digit();
  void set_has_decimal();
  void clear_has_decimal();
  void set_has_fraction();
  void clear_has_fraction();
  void set_has_time();
  void clear_has_time();
  void set_has_measure();
  void clear_has_measure();
  void set_has_percent();
  void clear_has_percent();
  void set_has_date();
  void clear_has_date();
  void set_has_telephone();
  void clear_has_telephone();
  void set_has_money();
  void clear_has_money();
  void set_has_electronic();
  void clear_has_electronic();
  void set_has_verbatim();
  void clear_has_verbatim();
  void set_has_letters();
  void clear_has_letters();
  void set_has_connector();
  void clear_has_connector();
  void set_has_abbreviation();
  void clear_has_abbreviation();
  void set_has_first_daughter();
  void clear_has_first_daughter();
  void set_has_last_daughter();
  void clear_has_last_daughter();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr wordid_;
  ::google::protobuf::internal::ArenaStringPtr spelling_;
  ::google::protobuf::internal::ArenaStringPtr spelling_with_stress_;
  ::google::protobuf::internal::ArenaStringPtr digit_;
  ::google::protobuf::internal::ArenaStringPtr verbatim_;
  ::google::protobuf::internal::ArenaStringPtr letters_;
  ::speech::sparrowhawk::Links* links_;
  ::speech::sparrowhawk::Cardinal* cardinal_;
  ::speech::sparrowhawk::Ordinal* ordinal_;
  ::speech::sparrowhawk::Decimal* decimal_;
  ::speech::sparrowhawk::Fraction* fraction_;
  ::speech::sparrowhawk::Time* time_;
  ::speech::sparrowhawk::Measure* measure_;
  ::speech::sparrowhawk::Decimal* percent_;
  ::speech::sparrowhawk::Date* date_;
  ::speech::sparrowhawk::Telephone* telephone_;
  ::speech::sparrowhawk::Money* money_;
  ::speech::sparrowhawk::Electronic* electronic_;
  ::speech::sparrowhawk::Connector* connector_;
  ::speech::sparrowhawk::Abbreviation* abbreviation_;
  ::google::protobuf::uint32 start_index_;
  ::google::protobuf::uint32 end_index_;
  float pause_duration_;
  int pause_length_;
  bool phrase_break_;
  bool skip_;
  bool next_space_;
  ::google::protobuf::int32 first_daughter_;
  ::google::protobuf::int32 last_daughter_;
  int type_;
  friend struct ::protobuf_items_2eproto::TableStruct;
  friend void ::protobuf_items_2eproto::InitDefaultsTokenImpl();
};
// -------------------------------------------------------------------

class Word : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Word) */ {
 public:
  Word();
  virtual ~Word();

  Word(const Word& from);

  inline Word& operator=(const Word& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Word(Word&& from) noexcept
    : Word() {
    *this = ::std::move(from);
  }

  inline Word& operator=(Word&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Word& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Word* internal_default_instance() {
    return reinterpret_cast<const Word*>(
               &_Word_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Word* other);
  friend void swap(Word& a, Word& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Word* New() const PROTOBUF_FINAL { return New(NULL); }

  Word* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Word& from);
  void MergeFrom(const Word& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Word* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string spelling = 3;
  bool has_spelling() const;
  void clear_spelling();
  static const int kSpellingFieldNumber = 3;
  const ::std::string& spelling() const;
  void set_spelling(const ::std::string& value);
  #if LANG_CXX11
  void set_spelling(::std::string&& value);
  #endif
  void set_spelling(const char* value);
  void set_spelling(const char* value, size_t size);
  ::std::string* mutable_spelling();
  ::std::string* release_spelling();
  void set_allocated_spelling(::std::string* spelling);

  // optional .speech.sparrowhawk.Links links = 1;
  bool has_links() const;
  void clear_links();
  static const int kLinksFieldNumber = 1;
  const ::speech::sparrowhawk::Links& links() const;
  ::speech::sparrowhawk::Links* mutable_links();
  ::speech::sparrowhawk::Links* release_links();
  void set_allocated_links(::speech::sparrowhawk::Links* links);

  // optional float pause_length = 4;
  bool has_pause_length() const;
  void clear_pause_length();
  static const int kPauseLengthFieldNumber = 4;
  float pause_length() const;
  void set_pause_length(float value);

  // optional bool precedes_pause = 5;
  bool has_precedes_pause() const;
  void clear_precedes_pause();
  static const int kPrecedesPauseFieldNumber = 5;
  bool precedes_pause() const;
  void set_precedes_pause(bool value);

  // optional int32 parent = 6;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 6;
  ::google::protobuf::int32 parent() const;
  void set_parent(::google::protobuf::int32 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Word)
  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Word)
 private:
  void set_has_links();
  void clear_has_links();
  void set_has_id();
  void clear_has_id();
  void set_has_spelling();
  void clear_has_spelling();
  void set_has_pause_length();
  void clear_has_pause_length();
  void set_has_precedes_pause();
  void clear_has_precedes_pause();
  void set_has_parent();
  void clear_has_parent();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr spelling_;
  ::speech::sparrowhawk::Links* links_;
  float pause_length_;
  bool precedes_pause_;
  ::google::protobuf::int32 parent_;
  friend struct ::protobuf_items_2eproto::TableStruct;
  friend void ::protobuf_items_2eproto::InitDefaultsWordImpl();
};
// -------------------------------------------------------------------

class LinguisticStructure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.LinguisticStructure) */ {
 public:
  LinguisticStructure();
  virtual ~LinguisticStructure();

  LinguisticStructure(const LinguisticStructure& from);

  inline LinguisticStructure& operator=(const LinguisticStructure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinguisticStructure(LinguisticStructure&& from) noexcept
    : LinguisticStructure() {
    *this = ::std::move(from);
  }

  inline LinguisticStructure& operator=(LinguisticStructure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinguisticStructure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinguisticStructure* internal_default_instance() {
    return reinterpret_cast<const LinguisticStructure*>(
               &_LinguisticStructure_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LinguisticStructure* other);
  friend void swap(LinguisticStructure& a, LinguisticStructure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinguisticStructure* New() const PROTOBUF_FINAL { return New(NULL); }

  LinguisticStructure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinguisticStructure& from);
  void MergeFrom(const LinguisticStructure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinguisticStructure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .speech.sparrowhawk.Token tokens = 3;
  int tokens_size() const;
  void clear_tokens();
  static const int kTokensFieldNumber = 3;
  const ::speech::sparrowhawk::Token& tokens(int index) const;
  ::speech::sparrowhawk::Token* mutable_tokens(int index);
  ::speech::sparrowhawk::Token* add_tokens();
  ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Token >*
      mutable_tokens();
  const ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Token >&
      tokens() const;

  // repeated .speech.sparrowhawk.Word words = 4;
  int words_size() const;
  void clear_words();
  static const int kWordsFieldNumber = 4;
  const ::speech::sparrowhawk::Word& words(int index) const;
  ::speech::sparrowhawk::Word* mutable_words(int index);
  ::speech::sparrowhawk::Word* add_words();
  ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Word >*
      mutable_words();
  const ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Word >&
      words() const;

  // optional string input = 2;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 2;
  const ::std::string& input() const;
  void set_input(const ::std::string& value);
  #if LANG_CXX11
  void set_input(::std::string&& value);
  #endif
  void set_input(const char* value);
  void set_input(const char* value, size_t size);
  ::std::string* mutable_input();
  ::std::string* release_input();
  void set_allocated_input(::std::string* input);

  // optional int64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(LinguisticStructure)
  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.LinguisticStructure)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_input();
  void clear_has_input();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Token > tokens_;
  ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Word > words_;
  ::google::protobuf::internal::ArenaStringPtr input_;
  ::google::protobuf::int64 id_;
  friend struct ::protobuf_items_2eproto::TableStruct;
  friend void ::protobuf_items_2eproto::InitDefaultsLinguisticStructureImpl();
};
// -------------------------------------------------------------------

class Utterance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Utterance) */ {
 public:
  Utterance();
  virtual ~Utterance();

  Utterance(const Utterance& from);

  inline Utterance& operator=(const Utterance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Utterance(Utterance&& from) noexcept
    : Utterance() {
    *this = ::std::move(from);
  }

  inline Utterance& operator=(Utterance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Utterance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Utterance* internal_default_instance() {
    return reinterpret_cast<const Utterance*>(
               &_Utterance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Utterance* other);
  friend void swap(Utterance& a, Utterance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Utterance* New() const PROTOBUF_FINAL { return New(NULL); }

  Utterance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Utterance& from);
  void MergeFrom(const Utterance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Utterance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string segmenter_output = 5;
  int segmenter_output_size() const;
  void clear_segmenter_output();
  static const int kSegmenterOutputFieldNumber = 5;
  const ::std::string& segmenter_output(int index) const;
  ::std::string* mutable_segmenter_output(int index);
  void set_segmenter_output(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_segmenter_output(int index, ::std::string&& value);
  #endif
  void set_segmenter_output(int index, const char* value);
  void set_segmenter_output(int index, const char* value, size_t size);
  ::std::string* add_segmenter_output();
  void add_segmenter_output(const ::std::string& value);
  #if LANG_CXX11
  void add_segmenter_output(::std::string&& value);
  #endif
  void add_segmenter_output(const char* value);
  void add_segmenter_output(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& segmenter_output() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_segmenter_output();

  // optional string filename = 2;
  bool has_filename() const;
  void clear_filename();
  static const int kFilenameFieldNumber = 2;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // optional string sentence = 3;
  bool has_sentence() const;
  void clear_sentence();
  static const int kSentenceFieldNumber = 3;
  const ::std::string& sentence() const;
  void set_sentence(const ::std::string& value);
  #if LANG_CXX11
  void set_sentence(::std::string&& value);
  #endif
  void set_sentence(const char* value);
  void set_sentence(const char* value, size_t size);
  ::std::string* mutable_sentence();
  ::std::string* release_sentence();
  void set_allocated_sentence(::std::string* sentence);

  // optional string original_sentence = 4;
  bool has_original_sentence() const;
  void clear_original_sentence();
  static const int kOriginalSentenceFieldNumber = 4;
  const ::std::string& original_sentence() const;
  void set_original_sentence(const ::std::string& value);
  #if LANG_CXX11
  void set_original_sentence(::std::string&& value);
  #endif
  void set_original_sentence(const char* value);
  void set_original_sentence(const char* value, size_t size);
  ::std::string* mutable_original_sentence();
  ::std::string* release_original_sentence();
  void set_allocated_original_sentence(::std::string* original_sentence);

  // optional .speech.sparrowhawk.LinguisticStructure linguistic = 6;
  bool has_linguistic() const;
  void clear_linguistic();
  static const int kLinguisticFieldNumber = 6;
  const ::speech::sparrowhawk::LinguisticStructure& linguistic() const;
  ::speech::sparrowhawk::LinguisticStructure* mutable_linguistic();
  ::speech::sparrowhawk::LinguisticStructure* release_linguistic();
  void set_allocated_linguistic(::speech::sparrowhawk::LinguisticStructure* linguistic);

  // optional uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Utterance)
  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Utterance)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_filename();
  void clear_has_filename();
  void set_has_sentence();
  void clear_has_sentence();
  void set_has_original_sentence();
  void clear_has_original_sentence();
  void set_has_linguistic();
  void clear_has_linguistic();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> segmenter_output_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::internal::ArenaStringPtr sentence_;
  ::google::protobuf::internal::ArenaStringPtr original_sentence_;
  ::speech::sparrowhawk::LinguisticStructure* linguistic_;
  ::google::protobuf::uint64 id_;
  friend struct ::protobuf_items_2eproto::TableStruct;
  friend void ::protobuf_items_2eproto::InitDefaultsUtteranceImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Token

// optional .speech.sparrowhawk.Links links = 1;
inline bool Token::has_links() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Token::set_has_links() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Token::clear_has_links() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Token::clear_links() {
  if (links_ != NULL) links_->::speech::sparrowhawk::Links::Clear();
  clear_has_links();
}
inline const ::speech::sparrowhawk::Links& Token::links() const {
  const ::speech::sparrowhawk::Links* p = links_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.links)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Links*>(
      &::speech::sparrowhawk::_Links_default_instance_);
}
inline ::speech::sparrowhawk::Links* Token::mutable_links() {
  set_has_links();
  if (links_ == NULL) {
    links_ = new ::speech::sparrowhawk::Links;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.links)
  return links_;
}
inline ::speech::sparrowhawk::Links* Token::release_links() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.links)
  clear_has_links();
  ::speech::sparrowhawk::Links* temp = links_;
  links_ = NULL;
  return temp;
}
inline void Token::set_allocated_links(::speech::sparrowhawk::Links* links) {
  delete links_;
  links_ = links;
  if (links) {
    set_has_links();
  } else {
    clear_has_links();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.links)
}

// optional uint32 start_index = 2;
inline bool Token::has_start_index() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Token::set_has_start_index() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Token::clear_has_start_index() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Token::clear_start_index() {
  start_index_ = 0u;
  clear_has_start_index();
}
inline ::google::protobuf::uint32 Token::start_index() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.start_index)
  return start_index_;
}
inline void Token::set_start_index(::google::protobuf::uint32 value) {
  set_has_start_index();
  start_index_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.start_index)
}

// optional uint32 end_index = 3;
inline bool Token::has_end_index() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Token::set_has_end_index() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Token::clear_has_end_index() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Token::clear_end_index() {
  end_index_ = 0u;
  clear_has_end_index();
}
inline ::google::protobuf::uint32 Token::end_index() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.end_index)
  return end_index_;
}
inline void Token::set_end_index(::google::protobuf::uint32 value) {
  set_has_end_index();
  end_index_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.end_index)
}

// optional string name = 4;
inline bool Token::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Token::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Token::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Token::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Token::name() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.name)
  return name_.GetNoArena();
}
inline void Token::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.name)
}
#if LANG_CXX11
inline void Token::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.name)
}
#endif
inline void Token::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.name)
}
inline void Token::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.name)
}
inline ::std::string* Token::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_name() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.name)
}

// optional .speech.sparrowhawk.Token.Type type = 5;
inline bool Token::has_type() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Token::set_has_type() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Token::clear_has_type() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Token::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::speech::sparrowhawk::Token_Type Token::type() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.type)
  return static_cast< ::speech::sparrowhawk::Token_Type >(type_);
}
inline void Token::set_type(::speech::sparrowhawk::Token_Type value) {
  assert(::speech::sparrowhawk::Token_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.type)
}

// optional string wordid = 6;
inline bool Token::has_wordid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Token::set_has_wordid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Token::clear_has_wordid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Token::clear_wordid() {
  wordid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_wordid();
}
inline const ::std::string& Token::wordid() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.wordid)
  return wordid_.GetNoArena();
}
inline void Token::set_wordid(const ::std::string& value) {
  set_has_wordid();
  wordid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.wordid)
}
#if LANG_CXX11
inline void Token::set_wordid(::std::string&& value) {
  set_has_wordid();
  wordid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.wordid)
}
#endif
inline void Token::set_wordid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_wordid();
  wordid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.wordid)
}
inline void Token::set_wordid(const char* value, size_t size) {
  set_has_wordid();
  wordid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.wordid)
}
inline ::std::string* Token::mutable_wordid() {
  set_has_wordid();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.wordid)
  return wordid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_wordid() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.wordid)
  clear_has_wordid();
  return wordid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_wordid(::std::string* wordid) {
  if (wordid != NULL) {
    set_has_wordid();
  } else {
    clear_has_wordid();
  }
  wordid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wordid);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.wordid)
}

// optional string spelling = 7;
inline bool Token::has_spelling() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Token::set_has_spelling() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Token::clear_has_spelling() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Token::clear_spelling() {
  spelling_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_spelling();
}
inline const ::std::string& Token::spelling() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.spelling)
  return spelling_.GetNoArena();
}
inline void Token::set_spelling(const ::std::string& value) {
  set_has_spelling();
  spelling_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.spelling)
}
#if LANG_CXX11
inline void Token::set_spelling(::std::string&& value) {
  set_has_spelling();
  spelling_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.spelling)
}
#endif
inline void Token::set_spelling(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_spelling();
  spelling_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.spelling)
}
inline void Token::set_spelling(const char* value, size_t size) {
  set_has_spelling();
  spelling_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.spelling)
}
inline ::std::string* Token::mutable_spelling() {
  set_has_spelling();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.spelling)
  return spelling_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_spelling() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.spelling)
  clear_has_spelling();
  return spelling_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_spelling(::std::string* spelling) {
  if (spelling != NULL) {
    set_has_spelling();
  } else {
    clear_has_spelling();
  }
  spelling_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), spelling);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.spelling)
}

// optional bool phrase_break = 8;
inline bool Token::has_phrase_break() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Token::set_has_phrase_break() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Token::clear_has_phrase_break() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Token::clear_phrase_break() {
  phrase_break_ = false;
  clear_has_phrase_break();
}
inline bool Token::phrase_break() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.phrase_break)
  return phrase_break_;
}
inline void Token::set_phrase_break(bool value) {
  set_has_phrase_break();
  phrase_break_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.phrase_break)
}

// optional float pause_duration = 9;
inline bool Token::has_pause_duration() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Token::set_has_pause_duration() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Token::clear_has_pause_duration() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Token::clear_pause_duration() {
  pause_duration_ = 0;
  clear_has_pause_duration();
}
inline float Token::pause_duration() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.pause_duration)
  return pause_duration_;
}
inline void Token::set_pause_duration(float value) {
  set_has_pause_duration();
  pause_duration_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.pause_duration)
}

// optional .speech.sparrowhawk.Token.PauseLength pause_length = 10 [default = PAUSE_NONE];
inline bool Token::has_pause_length() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Token::set_has_pause_length() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Token::clear_has_pause_length() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Token::clear_pause_length() {
  pause_length_ = 0;
  clear_has_pause_length();
}
inline ::speech::sparrowhawk::Token_PauseLength Token::pause_length() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.pause_length)
  return static_cast< ::speech::sparrowhawk::Token_PauseLength >(pause_length_);
}
inline void Token::set_pause_length(::speech::sparrowhawk::Token_PauseLength value) {
  assert(::speech::sparrowhawk::Token_PauseLength_IsValid(value));
  set_has_pause_length();
  pause_length_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.pause_length)
}

// optional string spelling_with_stress = 11;
inline bool Token::has_spelling_with_stress() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Token::set_has_spelling_with_stress() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Token::clear_has_spelling_with_stress() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Token::clear_spelling_with_stress() {
  spelling_with_stress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_spelling_with_stress();
}
inline const ::std::string& Token::spelling_with_stress() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.spelling_with_stress)
  return spelling_with_stress_.GetNoArena();
}
inline void Token::set_spelling_with_stress(const ::std::string& value) {
  set_has_spelling_with_stress();
  spelling_with_stress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.spelling_with_stress)
}
#if LANG_CXX11
inline void Token::set_spelling_with_stress(::std::string&& value) {
  set_has_spelling_with_stress();
  spelling_with_stress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.spelling_with_stress)
}
#endif
inline void Token::set_spelling_with_stress(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_spelling_with_stress();
  spelling_with_stress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.spelling_with_stress)
}
inline void Token::set_spelling_with_stress(const char* value, size_t size) {
  set_has_spelling_with_stress();
  spelling_with_stress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.spelling_with_stress)
}
inline ::std::string* Token::mutable_spelling_with_stress() {
  set_has_spelling_with_stress();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.spelling_with_stress)
  return spelling_with_stress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_spelling_with_stress() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.spelling_with_stress)
  clear_has_spelling_with_stress();
  return spelling_with_stress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_spelling_with_stress(::std::string* spelling_with_stress) {
  if (spelling_with_stress != NULL) {
    set_has_spelling_with_stress();
  } else {
    clear_has_spelling_with_stress();
  }
  spelling_with_stress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), spelling_with_stress);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.spelling_with_stress)
}

// optional bool skip = 12;
inline bool Token::has_skip() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Token::set_has_skip() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Token::clear_has_skip() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Token::clear_skip() {
  skip_ = false;
  clear_has_skip();
}
inline bool Token::skip() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.skip)
  return skip_;
}
inline void Token::set_skip(bool value) {
  set_has_skip();
  skip_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.skip)
}

// optional bool next_space = 13;
inline bool Token::has_next_space() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Token::set_has_next_space() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Token::clear_has_next_space() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Token::clear_next_space() {
  next_space_ = false;
  clear_has_next_space();
}
inline bool Token::next_space() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.next_space)
  return next_space_;
}
inline void Token::set_next_space(bool value) {
  set_has_next_space();
  next_space_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.next_space)
}

// optional .speech.sparrowhawk.Cardinal cardinal = 14;
inline bool Token::has_cardinal() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Token::set_has_cardinal() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Token::clear_has_cardinal() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Token::clear_cardinal() {
  if (cardinal_ != NULL) cardinal_->::speech::sparrowhawk::Cardinal::Clear();
  clear_has_cardinal();
}
inline const ::speech::sparrowhawk::Cardinal& Token::cardinal() const {
  const ::speech::sparrowhawk::Cardinal* p = cardinal_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.cardinal)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Cardinal*>(
      &::speech::sparrowhawk::_Cardinal_default_instance_);
}
inline ::speech::sparrowhawk::Cardinal* Token::mutable_cardinal() {
  set_has_cardinal();
  if (cardinal_ == NULL) {
    cardinal_ = new ::speech::sparrowhawk::Cardinal;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.cardinal)
  return cardinal_;
}
inline ::speech::sparrowhawk::Cardinal* Token::release_cardinal() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.cardinal)
  clear_has_cardinal();
  ::speech::sparrowhawk::Cardinal* temp = cardinal_;
  cardinal_ = NULL;
  return temp;
}
inline void Token::set_allocated_cardinal(::speech::sparrowhawk::Cardinal* cardinal) {
  delete cardinal_;
  cardinal_ = cardinal;
  if (cardinal) {
    set_has_cardinal();
  } else {
    clear_has_cardinal();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.cardinal)
}

// optional .speech.sparrowhawk.Ordinal ordinal = 15;
inline bool Token::has_ordinal() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Token::set_has_ordinal() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Token::clear_has_ordinal() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Token::clear_ordinal() {
  if (ordinal_ != NULL) ordinal_->::speech::sparrowhawk::Ordinal::Clear();
  clear_has_ordinal();
}
inline const ::speech::sparrowhawk::Ordinal& Token::ordinal() const {
  const ::speech::sparrowhawk::Ordinal* p = ordinal_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.ordinal)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Ordinal*>(
      &::speech::sparrowhawk::_Ordinal_default_instance_);
}
inline ::speech::sparrowhawk::Ordinal* Token::mutable_ordinal() {
  set_has_ordinal();
  if (ordinal_ == NULL) {
    ordinal_ = new ::speech::sparrowhawk::Ordinal;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.ordinal)
  return ordinal_;
}
inline ::speech::sparrowhawk::Ordinal* Token::release_ordinal() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.ordinal)
  clear_has_ordinal();
  ::speech::sparrowhawk::Ordinal* temp = ordinal_;
  ordinal_ = NULL;
  return temp;
}
inline void Token::set_allocated_ordinal(::speech::sparrowhawk::Ordinal* ordinal) {
  delete ordinal_;
  ordinal_ = ordinal;
  if (ordinal) {
    set_has_ordinal();
  } else {
    clear_has_ordinal();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.ordinal)
}

// optional string digit = 16;
inline bool Token::has_digit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Token::set_has_digit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Token::clear_has_digit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Token::clear_digit() {
  digit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_digit();
}
inline const ::std::string& Token::digit() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.digit)
  return digit_.GetNoArena();
}
inline void Token::set_digit(const ::std::string& value) {
  set_has_digit();
  digit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.digit)
}
#if LANG_CXX11
inline void Token::set_digit(::std::string&& value) {
  set_has_digit();
  digit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.digit)
}
#endif
inline void Token::set_digit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_digit();
  digit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.digit)
}
inline void Token::set_digit(const char* value, size_t size) {
  set_has_digit();
  digit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.digit)
}
inline ::std::string* Token::mutable_digit() {
  set_has_digit();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.digit)
  return digit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_digit() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.digit)
  clear_has_digit();
  return digit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_digit(::std::string* digit) {
  if (digit != NULL) {
    set_has_digit();
  } else {
    clear_has_digit();
  }
  digit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), digit);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.digit)
}

// optional .speech.sparrowhawk.Decimal decimal = 17;
inline bool Token::has_decimal() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Token::set_has_decimal() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Token::clear_has_decimal() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Token::clear_decimal() {
  if (decimal_ != NULL) decimal_->::speech::sparrowhawk::Decimal::Clear();
  clear_has_decimal();
}
inline const ::speech::sparrowhawk::Decimal& Token::decimal() const {
  const ::speech::sparrowhawk::Decimal* p = decimal_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.decimal)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Decimal*>(
      &::speech::sparrowhawk::_Decimal_default_instance_);
}
inline ::speech::sparrowhawk::Decimal* Token::mutable_decimal() {
  set_has_decimal();
  if (decimal_ == NULL) {
    decimal_ = new ::speech::sparrowhawk::Decimal;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.decimal)
  return decimal_;
}
inline ::speech::sparrowhawk::Decimal* Token::release_decimal() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.decimal)
  clear_has_decimal();
  ::speech::sparrowhawk::Decimal* temp = decimal_;
  decimal_ = NULL;
  return temp;
}
inline void Token::set_allocated_decimal(::speech::sparrowhawk::Decimal* decimal) {
  delete decimal_;
  decimal_ = decimal;
  if (decimal) {
    set_has_decimal();
  } else {
    clear_has_decimal();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.decimal)
}

// optional .speech.sparrowhawk.Fraction fraction = 18;
inline bool Token::has_fraction() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Token::set_has_fraction() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Token::clear_has_fraction() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Token::clear_fraction() {
  if (fraction_ != NULL) fraction_->::speech::sparrowhawk::Fraction::Clear();
  clear_has_fraction();
}
inline const ::speech::sparrowhawk::Fraction& Token::fraction() const {
  const ::speech::sparrowhawk::Fraction* p = fraction_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.fraction)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Fraction*>(
      &::speech::sparrowhawk::_Fraction_default_instance_);
}
inline ::speech::sparrowhawk::Fraction* Token::mutable_fraction() {
  set_has_fraction();
  if (fraction_ == NULL) {
    fraction_ = new ::speech::sparrowhawk::Fraction;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.fraction)
  return fraction_;
}
inline ::speech::sparrowhawk::Fraction* Token::release_fraction() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.fraction)
  clear_has_fraction();
  ::speech::sparrowhawk::Fraction* temp = fraction_;
  fraction_ = NULL;
  return temp;
}
inline void Token::set_allocated_fraction(::speech::sparrowhawk::Fraction* fraction) {
  delete fraction_;
  fraction_ = fraction;
  if (fraction) {
    set_has_fraction();
  } else {
    clear_has_fraction();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.fraction)
}

// optional .speech.sparrowhawk.Time time = 19;
inline bool Token::has_time() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Token::set_has_time() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Token::clear_has_time() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Token::clear_time() {
  if (time_ != NULL) time_->::speech::sparrowhawk::Time::Clear();
  clear_has_time();
}
inline const ::speech::sparrowhawk::Time& Token::time() const {
  const ::speech::sparrowhawk::Time* p = time_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.time)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Time*>(
      &::speech::sparrowhawk::_Time_default_instance_);
}
inline ::speech::sparrowhawk::Time* Token::mutable_time() {
  set_has_time();
  if (time_ == NULL) {
    time_ = new ::speech::sparrowhawk::Time;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.time)
  return time_;
}
inline ::speech::sparrowhawk::Time* Token::release_time() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.time)
  clear_has_time();
  ::speech::sparrowhawk::Time* temp = time_;
  time_ = NULL;
  return temp;
}
inline void Token::set_allocated_time(::speech::sparrowhawk::Time* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.time)
}

// optional .speech.sparrowhawk.Measure measure = 20;
inline bool Token::has_measure() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Token::set_has_measure() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Token::clear_has_measure() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Token::clear_measure() {
  if (measure_ != NULL) measure_->::speech::sparrowhawk::Measure::Clear();
  clear_has_measure();
}
inline const ::speech::sparrowhawk::Measure& Token::measure() const {
  const ::speech::sparrowhawk::Measure* p = measure_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.measure)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Measure*>(
      &::speech::sparrowhawk::_Measure_default_instance_);
}
inline ::speech::sparrowhawk::Measure* Token::mutable_measure() {
  set_has_measure();
  if (measure_ == NULL) {
    measure_ = new ::speech::sparrowhawk::Measure;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.measure)
  return measure_;
}
inline ::speech::sparrowhawk::Measure* Token::release_measure() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.measure)
  clear_has_measure();
  ::speech::sparrowhawk::Measure* temp = measure_;
  measure_ = NULL;
  return temp;
}
inline void Token::set_allocated_measure(::speech::sparrowhawk::Measure* measure) {
  delete measure_;
  measure_ = measure;
  if (measure) {
    set_has_measure();
  } else {
    clear_has_measure();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.measure)
}

// optional .speech.sparrowhawk.Decimal percent = 21;
inline bool Token::has_percent() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Token::set_has_percent() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Token::clear_has_percent() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Token::clear_percent() {
  if (percent_ != NULL) percent_->::speech::sparrowhawk::Decimal::Clear();
  clear_has_percent();
}
inline const ::speech::sparrowhawk::Decimal& Token::percent() const {
  const ::speech::sparrowhawk::Decimal* p = percent_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.percent)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Decimal*>(
      &::speech::sparrowhawk::_Decimal_default_instance_);
}
inline ::speech::sparrowhawk::Decimal* Token::mutable_percent() {
  set_has_percent();
  if (percent_ == NULL) {
    percent_ = new ::speech::sparrowhawk::Decimal;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.percent)
  return percent_;
}
inline ::speech::sparrowhawk::Decimal* Token::release_percent() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.percent)
  clear_has_percent();
  ::speech::sparrowhawk::Decimal* temp = percent_;
  percent_ = NULL;
  return temp;
}
inline void Token::set_allocated_percent(::speech::sparrowhawk::Decimal* percent) {
  delete percent_;
  percent_ = percent;
  if (percent) {
    set_has_percent();
  } else {
    clear_has_percent();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.percent)
}

// optional .speech.sparrowhawk.Date date = 22;
inline bool Token::has_date() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Token::set_has_date() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Token::clear_has_date() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Token::clear_date() {
  if (date_ != NULL) date_->::speech::sparrowhawk::Date::Clear();
  clear_has_date();
}
inline const ::speech::sparrowhawk::Date& Token::date() const {
  const ::speech::sparrowhawk::Date* p = date_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.date)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Date*>(
      &::speech::sparrowhawk::_Date_default_instance_);
}
inline ::speech::sparrowhawk::Date* Token::mutable_date() {
  set_has_date();
  if (date_ == NULL) {
    date_ = new ::speech::sparrowhawk::Date;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.date)
  return date_;
}
inline ::speech::sparrowhawk::Date* Token::release_date() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.date)
  clear_has_date();
  ::speech::sparrowhawk::Date* temp = date_;
  date_ = NULL;
  return temp;
}
inline void Token::set_allocated_date(::speech::sparrowhawk::Date* date) {
  delete date_;
  date_ = date;
  if (date) {
    set_has_date();
  } else {
    clear_has_date();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.date)
}

// optional .speech.sparrowhawk.Telephone telephone = 23;
inline bool Token::has_telephone() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Token::set_has_telephone() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Token::clear_has_telephone() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Token::clear_telephone() {
  if (telephone_ != NULL) telephone_->::speech::sparrowhawk::Telephone::Clear();
  clear_has_telephone();
}
inline const ::speech::sparrowhawk::Telephone& Token::telephone() const {
  const ::speech::sparrowhawk::Telephone* p = telephone_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.telephone)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Telephone*>(
      &::speech::sparrowhawk::_Telephone_default_instance_);
}
inline ::speech::sparrowhawk::Telephone* Token::mutable_telephone() {
  set_has_telephone();
  if (telephone_ == NULL) {
    telephone_ = new ::speech::sparrowhawk::Telephone;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.telephone)
  return telephone_;
}
inline ::speech::sparrowhawk::Telephone* Token::release_telephone() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.telephone)
  clear_has_telephone();
  ::speech::sparrowhawk::Telephone* temp = telephone_;
  telephone_ = NULL;
  return temp;
}
inline void Token::set_allocated_telephone(::speech::sparrowhawk::Telephone* telephone) {
  delete telephone_;
  telephone_ = telephone;
  if (telephone) {
    set_has_telephone();
  } else {
    clear_has_telephone();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.telephone)
}

// optional .speech.sparrowhawk.Money money = 24;
inline bool Token::has_money() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Token::set_has_money() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Token::clear_has_money() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Token::clear_money() {
  if (money_ != NULL) money_->::speech::sparrowhawk::Money::Clear();
  clear_has_money();
}
inline const ::speech::sparrowhawk::Money& Token::money() const {
  const ::speech::sparrowhawk::Money* p = money_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.money)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Money*>(
      &::speech::sparrowhawk::_Money_default_instance_);
}
inline ::speech::sparrowhawk::Money* Token::mutable_money() {
  set_has_money();
  if (money_ == NULL) {
    money_ = new ::speech::sparrowhawk::Money;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.money)
  return money_;
}
inline ::speech::sparrowhawk::Money* Token::release_money() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.money)
  clear_has_money();
  ::speech::sparrowhawk::Money* temp = money_;
  money_ = NULL;
  return temp;
}
inline void Token::set_allocated_money(::speech::sparrowhawk::Money* money) {
  delete money_;
  money_ = money;
  if (money) {
    set_has_money();
  } else {
    clear_has_money();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.money)
}

// optional .speech.sparrowhawk.Electronic electronic = 25;
inline bool Token::has_electronic() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Token::set_has_electronic() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Token::clear_has_electronic() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Token::clear_electronic() {
  if (electronic_ != NULL) electronic_->::speech::sparrowhawk::Electronic::Clear();
  clear_has_electronic();
}
inline const ::speech::sparrowhawk::Electronic& Token::electronic() const {
  const ::speech::sparrowhawk::Electronic* p = electronic_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.electronic)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Electronic*>(
      &::speech::sparrowhawk::_Electronic_default_instance_);
}
inline ::speech::sparrowhawk::Electronic* Token::mutable_electronic() {
  set_has_electronic();
  if (electronic_ == NULL) {
    electronic_ = new ::speech::sparrowhawk::Electronic;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.electronic)
  return electronic_;
}
inline ::speech::sparrowhawk::Electronic* Token::release_electronic() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.electronic)
  clear_has_electronic();
  ::speech::sparrowhawk::Electronic* temp = electronic_;
  electronic_ = NULL;
  return temp;
}
inline void Token::set_allocated_electronic(::speech::sparrowhawk::Electronic* electronic) {
  delete electronic_;
  electronic_ = electronic;
  if (electronic) {
    set_has_electronic();
  } else {
    clear_has_electronic();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.electronic)
}

// optional string verbatim = 26;
inline bool Token::has_verbatim() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Token::set_has_verbatim() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Token::clear_has_verbatim() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Token::clear_verbatim() {
  verbatim_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verbatim();
}
inline const ::std::string& Token::verbatim() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.verbatim)
  return verbatim_.GetNoArena();
}
inline void Token::set_verbatim(const ::std::string& value) {
  set_has_verbatim();
  verbatim_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.verbatim)
}
#if LANG_CXX11
inline void Token::set_verbatim(::std::string&& value) {
  set_has_verbatim();
  verbatim_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.verbatim)
}
#endif
inline void Token::set_verbatim(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verbatim();
  verbatim_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.verbatim)
}
inline void Token::set_verbatim(const char* value, size_t size) {
  set_has_verbatim();
  verbatim_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.verbatim)
}
inline ::std::string* Token::mutable_verbatim() {
  set_has_verbatim();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.verbatim)
  return verbatim_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_verbatim() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.verbatim)
  clear_has_verbatim();
  return verbatim_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_verbatim(::std::string* verbatim) {
  if (verbatim != NULL) {
    set_has_verbatim();
  } else {
    clear_has_verbatim();
  }
  verbatim_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verbatim);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.verbatim)
}

// optional string letters = 27;
inline bool Token::has_letters() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Token::set_has_letters() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Token::clear_has_letters() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Token::clear_letters() {
  letters_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_letters();
}
inline const ::std::string& Token::letters() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.letters)
  return letters_.GetNoArena();
}
inline void Token::set_letters(const ::std::string& value) {
  set_has_letters();
  letters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.letters)
}
#if LANG_CXX11
inline void Token::set_letters(::std::string&& value) {
  set_has_letters();
  letters_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.letters)
}
#endif
inline void Token::set_letters(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_letters();
  letters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.letters)
}
inline void Token::set_letters(const char* value, size_t size) {
  set_has_letters();
  letters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.letters)
}
inline ::std::string* Token::mutable_letters() {
  set_has_letters();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.letters)
  return letters_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_letters() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.letters)
  clear_has_letters();
  return letters_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_letters(::std::string* letters) {
  if (letters != NULL) {
    set_has_letters();
  } else {
    clear_has_letters();
  }
  letters_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), letters);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.letters)
}

// optional .speech.sparrowhawk.Connector connector = 28;
inline bool Token::has_connector() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Token::set_has_connector() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Token::clear_has_connector() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Token::clear_connector() {
  if (connector_ != NULL) connector_->::speech::sparrowhawk::Connector::Clear();
  clear_has_connector();
}
inline const ::speech::sparrowhawk::Connector& Token::connector() const {
  const ::speech::sparrowhawk::Connector* p = connector_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.connector)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Connector*>(
      &::speech::sparrowhawk::_Connector_default_instance_);
}
inline ::speech::sparrowhawk::Connector* Token::mutable_connector() {
  set_has_connector();
  if (connector_ == NULL) {
    connector_ = new ::speech::sparrowhawk::Connector;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.connector)
  return connector_;
}
inline ::speech::sparrowhawk::Connector* Token::release_connector() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.connector)
  clear_has_connector();
  ::speech::sparrowhawk::Connector* temp = connector_;
  connector_ = NULL;
  return temp;
}
inline void Token::set_allocated_connector(::speech::sparrowhawk::Connector* connector) {
  delete connector_;
  connector_ = connector;
  if (connector) {
    set_has_connector();
  } else {
    clear_has_connector();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.connector)
}

// optional .speech.sparrowhawk.Abbreviation abbreviation = 29;
inline bool Token::has_abbreviation() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Token::set_has_abbreviation() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Token::clear_has_abbreviation() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Token::clear_abbreviation() {
  if (abbreviation_ != NULL) abbreviation_->::speech::sparrowhawk::Abbreviation::Clear();
  clear_has_abbreviation();
}
inline const ::speech::sparrowhawk::Abbreviation& Token::abbreviation() const {
  const ::speech::sparrowhawk::Abbreviation* p = abbreviation_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.abbreviation)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Abbreviation*>(
      &::speech::sparrowhawk::_Abbreviation_default_instance_);
}
inline ::speech::sparrowhawk::Abbreviation* Token::mutable_abbreviation() {
  set_has_abbreviation();
  if (abbreviation_ == NULL) {
    abbreviation_ = new ::speech::sparrowhawk::Abbreviation;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.abbreviation)
  return abbreviation_;
}
inline ::speech::sparrowhawk::Abbreviation* Token::release_abbreviation() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.abbreviation)
  clear_has_abbreviation();
  ::speech::sparrowhawk::Abbreviation* temp = abbreviation_;
  abbreviation_ = NULL;
  return temp;
}
inline void Token::set_allocated_abbreviation(::speech::sparrowhawk::Abbreviation* abbreviation) {
  delete abbreviation_;
  abbreviation_ = abbreviation;
  if (abbreviation) {
    set_has_abbreviation();
  } else {
    clear_has_abbreviation();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.abbreviation)
}

// optional int32 first_daughter = 30;
inline bool Token::has_first_daughter() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Token::set_has_first_daughter() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Token::clear_has_first_daughter() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Token::clear_first_daughter() {
  first_daughter_ = 0;
  clear_has_first_daughter();
}
inline ::google::protobuf::int32 Token::first_daughter() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.first_daughter)
  return first_daughter_;
}
inline void Token::set_first_daughter(::google::protobuf::int32 value) {
  set_has_first_daughter();
  first_daughter_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.first_daughter)
}

// optional int32 last_daughter = 31;
inline bool Token::has_last_daughter() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Token::set_has_last_daughter() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Token::clear_has_last_daughter() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Token::clear_last_daughter() {
  last_daughter_ = 0;
  clear_has_last_daughter();
}
inline ::google::protobuf::int32 Token::last_daughter() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.last_daughter)
  return last_daughter_;
}
inline void Token::set_last_daughter(::google::protobuf::int32 value) {
  set_has_last_daughter();
  last_daughter_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.last_daughter)
}

// -------------------------------------------------------------------

// Word

// optional .speech.sparrowhawk.Links links = 1;
inline bool Word::has_links() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Word::set_has_links() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Word::clear_has_links() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Word::clear_links() {
  if (links_ != NULL) links_->::speech::sparrowhawk::Links::Clear();
  clear_has_links();
}
inline const ::speech::sparrowhawk::Links& Word::links() const {
  const ::speech::sparrowhawk::Links* p = links_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Word.links)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Links*>(
      &::speech::sparrowhawk::_Links_default_instance_);
}
inline ::speech::sparrowhawk::Links* Word::mutable_links() {
  set_has_links();
  if (links_ == NULL) {
    links_ = new ::speech::sparrowhawk::Links;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Word.links)
  return links_;
}
inline ::speech::sparrowhawk::Links* Word::release_links() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Word.links)
  clear_has_links();
  ::speech::sparrowhawk::Links* temp = links_;
  links_ = NULL;
  return temp;
}
inline void Word::set_allocated_links(::speech::sparrowhawk::Links* links) {
  delete links_;
  links_ = links;
  if (links) {
    set_has_links();
  } else {
    clear_has_links();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Word.links)
}

// optional string id = 2;
inline bool Word::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Word::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Word::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Word::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Word::id() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Word.id)
  return id_.GetNoArena();
}
inline void Word::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Word.id)
}
#if LANG_CXX11
inline void Word::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Word.id)
}
#endif
inline void Word::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Word.id)
}
inline void Word::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Word.id)
}
inline ::std::string* Word::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Word.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Word::release_id() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Word.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Word::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Word.id)
}

// optional string spelling = 3;
inline bool Word::has_spelling() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Word::set_has_spelling() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Word::clear_has_spelling() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Word::clear_spelling() {
  spelling_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_spelling();
}
inline const ::std::string& Word::spelling() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Word.spelling)
  return spelling_.GetNoArena();
}
inline void Word::set_spelling(const ::std::string& value) {
  set_has_spelling();
  spelling_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Word.spelling)
}
#if LANG_CXX11
inline void Word::set_spelling(::std::string&& value) {
  set_has_spelling();
  spelling_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Word.spelling)
}
#endif
inline void Word::set_spelling(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_spelling();
  spelling_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Word.spelling)
}
inline void Word::set_spelling(const char* value, size_t size) {
  set_has_spelling();
  spelling_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Word.spelling)
}
inline ::std::string* Word::mutable_spelling() {
  set_has_spelling();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Word.spelling)
  return spelling_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Word::release_spelling() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Word.spelling)
  clear_has_spelling();
  return spelling_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Word::set_allocated_spelling(::std::string* spelling) {
  if (spelling != NULL) {
    set_has_spelling();
  } else {
    clear_has_spelling();
  }
  spelling_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), spelling);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Word.spelling)
}

// optional float pause_length = 4;
inline bool Word::has_pause_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Word::set_has_pause_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Word::clear_has_pause_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Word::clear_pause_length() {
  pause_length_ = 0;
  clear_has_pause_length();
}
inline float Word::pause_length() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Word.pause_length)
  return pause_length_;
}
inline void Word::set_pause_length(float value) {
  set_has_pause_length();
  pause_length_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Word.pause_length)
}

// optional bool precedes_pause = 5;
inline bool Word::has_precedes_pause() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Word::set_has_precedes_pause() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Word::clear_has_precedes_pause() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Word::clear_precedes_pause() {
  precedes_pause_ = false;
  clear_has_precedes_pause();
}
inline bool Word::precedes_pause() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Word.precedes_pause)
  return precedes_pause_;
}
inline void Word::set_precedes_pause(bool value) {
  set_has_precedes_pause();
  precedes_pause_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Word.precedes_pause)
}

// optional int32 parent = 6;
inline bool Word::has_parent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Word::set_has_parent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Word::clear_has_parent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Word::clear_parent() {
  parent_ = 0;
  clear_has_parent();
}
inline ::google::protobuf::int32 Word::parent() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Word.parent)
  return parent_;
}
inline void Word::set_parent(::google::protobuf::int32 value) {
  set_has_parent();
  parent_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Word.parent)
}

// -------------------------------------------------------------------

// LinguisticStructure

// optional int64 id = 1;
inline bool LinguisticStructure::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinguisticStructure::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinguisticStructure::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinguisticStructure::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 LinguisticStructure::id() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.LinguisticStructure.id)
  return id_;
}
inline void LinguisticStructure::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.LinguisticStructure.id)
}

// optional string input = 2;
inline bool LinguisticStructure::has_input() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinguisticStructure::set_has_input() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinguisticStructure::clear_has_input() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinguisticStructure::clear_input() {
  input_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_input();
}
inline const ::std::string& LinguisticStructure::input() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.LinguisticStructure.input)
  return input_.GetNoArena();
}
inline void LinguisticStructure::set_input(const ::std::string& value) {
  set_has_input();
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.LinguisticStructure.input)
}
#if LANG_CXX11
inline void LinguisticStructure::set_input(::std::string&& value) {
  set_has_input();
  input_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.LinguisticStructure.input)
}
#endif
inline void LinguisticStructure::set_input(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_input();
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.LinguisticStructure.input)
}
inline void LinguisticStructure::set_input(const char* value, size_t size) {
  set_has_input();
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.LinguisticStructure.input)
}
inline ::std::string* LinguisticStructure::mutable_input() {
  set_has_input();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.LinguisticStructure.input)
  return input_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinguisticStructure::release_input() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.LinguisticStructure.input)
  clear_has_input();
  return input_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinguisticStructure::set_allocated_input(::std::string* input) {
  if (input != NULL) {
    set_has_input();
  } else {
    clear_has_input();
  }
  input_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.LinguisticStructure.input)
}

// repeated .speech.sparrowhawk.Token tokens = 3;
inline int LinguisticStructure::tokens_size() const {
  return tokens_.size();
}
inline void LinguisticStructure::clear_tokens() {
  tokens_.Clear();
}
inline const ::speech::sparrowhawk::Token& LinguisticStructure::tokens(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.LinguisticStructure.tokens)
  return tokens_.Get(index);
}
inline ::speech::sparrowhawk::Token* LinguisticStructure::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.LinguisticStructure.tokens)
  return tokens_.Mutable(index);
}
inline ::speech::sparrowhawk::Token* LinguisticStructure::add_tokens() {
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.LinguisticStructure.tokens)
  return tokens_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Token >*
LinguisticStructure::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.LinguisticStructure.tokens)
  return &tokens_;
}
inline const ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Token >&
LinguisticStructure::tokens() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.LinguisticStructure.tokens)
  return tokens_;
}

// repeated .speech.sparrowhawk.Word words = 4;
inline int LinguisticStructure::words_size() const {
  return words_.size();
}
inline void LinguisticStructure::clear_words() {
  words_.Clear();
}
inline const ::speech::sparrowhawk::Word& LinguisticStructure::words(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.LinguisticStructure.words)
  return words_.Get(index);
}
inline ::speech::sparrowhawk::Word* LinguisticStructure::mutable_words(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.LinguisticStructure.words)
  return words_.Mutable(index);
}
inline ::speech::sparrowhawk::Word* LinguisticStructure::add_words() {
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.LinguisticStructure.words)
  return words_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Word >*
LinguisticStructure::mutable_words() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.LinguisticStructure.words)
  return &words_;
}
inline const ::google::protobuf::RepeatedPtrField< ::speech::sparrowhawk::Word >&
LinguisticStructure::words() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.LinguisticStructure.words)
  return words_;
}

// -------------------------------------------------------------------

// Utterance

// optional uint64 id = 1;
inline bool Utterance::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Utterance::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Utterance::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Utterance::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Utterance::id() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Utterance.id)
  return id_;
}
inline void Utterance::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Utterance.id)
}

// optional string filename = 2;
inline bool Utterance::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Utterance::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Utterance::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Utterance::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filename();
}
inline const ::std::string& Utterance::filename() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Utterance.filename)
  return filename_.GetNoArena();
}
inline void Utterance::set_filename(const ::std::string& value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Utterance.filename)
}
#if LANG_CXX11
inline void Utterance::set_filename(::std::string&& value) {
  set_has_filename();
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Utterance.filename)
}
#endif
inline void Utterance::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Utterance.filename)
}
inline void Utterance::set_filename(const char* value, size_t size) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Utterance.filename)
}
inline ::std::string* Utterance::mutable_filename() {
  set_has_filename();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Utterance.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utterance::release_filename() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Utterance.filename)
  clear_has_filename();
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utterance::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    set_has_filename();
  } else {
    clear_has_filename();
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Utterance.filename)
}

// optional string sentence = 3;
inline bool Utterance::has_sentence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Utterance::set_has_sentence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Utterance::clear_has_sentence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Utterance::clear_sentence() {
  sentence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sentence();
}
inline const ::std::string& Utterance::sentence() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Utterance.sentence)
  return sentence_.GetNoArena();
}
inline void Utterance::set_sentence(const ::std::string& value) {
  set_has_sentence();
  sentence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Utterance.sentence)
}
#if LANG_CXX11
inline void Utterance::set_sentence(::std::string&& value) {
  set_has_sentence();
  sentence_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Utterance.sentence)
}
#endif
inline void Utterance::set_sentence(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sentence();
  sentence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Utterance.sentence)
}
inline void Utterance::set_sentence(const char* value, size_t size) {
  set_has_sentence();
  sentence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Utterance.sentence)
}
inline ::std::string* Utterance::mutable_sentence() {
  set_has_sentence();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Utterance.sentence)
  return sentence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utterance::release_sentence() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Utterance.sentence)
  clear_has_sentence();
  return sentence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utterance::set_allocated_sentence(::std::string* sentence) {
  if (sentence != NULL) {
    set_has_sentence();
  } else {
    clear_has_sentence();
  }
  sentence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sentence);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Utterance.sentence)
}

// optional string original_sentence = 4;
inline bool Utterance::has_original_sentence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Utterance::set_has_original_sentence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Utterance::clear_has_original_sentence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Utterance::clear_original_sentence() {
  original_sentence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_original_sentence();
}
inline const ::std::string& Utterance::original_sentence() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Utterance.original_sentence)
  return original_sentence_.GetNoArena();
}
inline void Utterance::set_original_sentence(const ::std::string& value) {
  set_has_original_sentence();
  original_sentence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Utterance.original_sentence)
}
#if LANG_CXX11
inline void Utterance::set_original_sentence(::std::string&& value) {
  set_has_original_sentence();
  original_sentence_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Utterance.original_sentence)
}
#endif
inline void Utterance::set_original_sentence(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_original_sentence();
  original_sentence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Utterance.original_sentence)
}
inline void Utterance::set_original_sentence(const char* value, size_t size) {
  set_has_original_sentence();
  original_sentence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Utterance.original_sentence)
}
inline ::std::string* Utterance::mutable_original_sentence() {
  set_has_original_sentence();
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Utterance.original_sentence)
  return original_sentence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utterance::release_original_sentence() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Utterance.original_sentence)
  clear_has_original_sentence();
  return original_sentence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utterance::set_allocated_original_sentence(::std::string* original_sentence) {
  if (original_sentence != NULL) {
    set_has_original_sentence();
  } else {
    clear_has_original_sentence();
  }
  original_sentence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), original_sentence);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Utterance.original_sentence)
}

// repeated string segmenter_output = 5;
inline int Utterance::segmenter_output_size() const {
  return segmenter_output_.size();
}
inline void Utterance::clear_segmenter_output() {
  segmenter_output_.Clear();
}
inline const ::std::string& Utterance::segmenter_output(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Utterance.segmenter_output)
  return segmenter_output_.Get(index);
}
inline ::std::string* Utterance::mutable_segmenter_output(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Utterance.segmenter_output)
  return segmenter_output_.Mutable(index);
}
inline void Utterance::set_segmenter_output(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Utterance.segmenter_output)
  segmenter_output_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Utterance::set_segmenter_output(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Utterance.segmenter_output)
  segmenter_output_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Utterance::set_segmenter_output(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  segmenter_output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Utterance.segmenter_output)
}
inline void Utterance::set_segmenter_output(int index, const char* value, size_t size) {
  segmenter_output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Utterance.segmenter_output)
}
inline ::std::string* Utterance::add_segmenter_output() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Utterance.segmenter_output)
  return segmenter_output_.Add();
}
inline void Utterance::add_segmenter_output(const ::std::string& value) {
  segmenter_output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Utterance.segmenter_output)
}
#if LANG_CXX11
inline void Utterance::add_segmenter_output(::std::string&& value) {
  segmenter_output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Utterance.segmenter_output)
}
#endif
inline void Utterance::add_segmenter_output(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  segmenter_output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Utterance.segmenter_output)
}
inline void Utterance::add_segmenter_output(const char* value, size_t size) {
  segmenter_output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Utterance.segmenter_output)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Utterance::segmenter_output() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Utterance.segmenter_output)
  return segmenter_output_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Utterance::mutable_segmenter_output() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Utterance.segmenter_output)
  return &segmenter_output_;
}

// optional .speech.sparrowhawk.LinguisticStructure linguistic = 6;
inline bool Utterance::has_linguistic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Utterance::set_has_linguistic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Utterance::clear_has_linguistic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Utterance::clear_linguistic() {
  if (linguistic_ != NULL) linguistic_->::speech::sparrowhawk::LinguisticStructure::Clear();
  clear_has_linguistic();
}
inline const ::speech::sparrowhawk::LinguisticStructure& Utterance::linguistic() const {
  const ::speech::sparrowhawk::LinguisticStructure* p = linguistic_;
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Utterance.linguistic)
  return p != NULL ? *p : *reinterpret_cast<const ::speech::sparrowhawk::LinguisticStructure*>(
      &::speech::sparrowhawk::_LinguisticStructure_default_instance_);
}
inline ::speech::sparrowhawk::LinguisticStructure* Utterance::mutable_linguistic() {
  set_has_linguistic();
  if (linguistic_ == NULL) {
    linguistic_ = new ::speech::sparrowhawk::LinguisticStructure;
  }
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Utterance.linguistic)
  return linguistic_;
}
inline ::speech::sparrowhawk::LinguisticStructure* Utterance::release_linguistic() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Utterance.linguistic)
  clear_has_linguistic();
  ::speech::sparrowhawk::LinguisticStructure* temp = linguistic_;
  linguistic_ = NULL;
  return temp;
}
inline void Utterance::set_allocated_linguistic(::speech::sparrowhawk::LinguisticStructure* linguistic) {
  delete linguistic_;
  linguistic_ = linguistic;
  if (linguistic) {
    set_has_linguistic();
  } else {
    clear_has_linguistic();
  }
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Utterance.linguistic)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sparrowhawk
}  // namespace speech

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::speech::sparrowhawk::Token_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speech::sparrowhawk::Token_Type>() {
  return ::speech::sparrowhawk::Token_Type_descriptor();
}
template <> struct is_proto_enum< ::speech::sparrowhawk::Token_PauseLength> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speech::sparrowhawk::Token_PauseLength>() {
  return ::speech::sparrowhawk::Token_PauseLength_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_items_2eproto__INCLUDED
